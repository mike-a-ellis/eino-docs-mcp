---
phase: 01-storage-foundation
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - internal/storage/qdrant.go
  - internal/storage/qdrant_test.go
autonomous: true

must_haves:
  truths:
    - "Parent documents are stored in Qdrant with full content and metadata"
    - "Chunks are stored with embeddings and linked to parent documents"
    - "Documents can be retrieved by ID with full content"
    - "Chunks can be searched by vector similarity"
    - "Data persists across Qdrant container restarts"
    - "Commit SHA is tracked and queryable for indexed content"
  artifacts:
    - path: "internal/storage/qdrant.go"
      provides: "Document and chunk storage/retrieval operations"
      exports: ["UpsertDocument", "UpsertChunks", "GetDocument", "SearchChunks", "GetCommitSHA"]
      min_lines: 200
    - path: "internal/storage/qdrant_test.go"
      provides: "Integration tests proving storage persistence"
      contains: "TestPersistence"
      min_lines: 50
  key_links:
    - from: "internal/storage/qdrant.go"
      to: "qdrant.Upsert"
      via: "point insertion"
      pattern: "client\\.Upsert"
    - from: "internal/storage/qdrant.go"
      to: "qdrant.Query"
      via: "vector search"
      pattern: "client\\.Query"
    - from: "internal/storage/qdrant_test.go"
      to: "internal/storage/qdrant.go"
      via: "test coverage"
      pattern: "storage\\.NewQdrantStorage"
---

<objective>
Implement document storage operations and prove data persistence with integration tests.

Purpose: Complete the storage layer with all CRUD operations needed by downstream phases. The integration test proves the core phase goal - data persists across restarts.

Output: Working document storage with upsert, retrieval, and search operations. Integration test demonstrates persistence.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-CONTEXT.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md
@.planning/phases/01-storage-foundation/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement document and chunk storage operations</name>
  <files>internal/storage/qdrant.go</files>
  <action>
Add methods to QdrantStorage for storing and retrieving documents and chunks.

Add to internal/storage/qdrant.go:

1. UpsertDocument(ctx, doc *Document) error
   - Create Qdrant point from Document
   - Point ID from doc.ID (UUID)
   - No vector (parent docs don't have embeddings)
   - Payload includes:
     - type: "parent"
     - content: doc.Content
     - path: doc.Metadata.Path
     - url: doc.Metadata.URL
     - repository: doc.Metadata.Repository
     - commit_sha: doc.Metadata.CommitSHA
     - indexed_at: doc.Metadata.IndexedAt.Format(time.RFC3339)
     - summary: doc.Metadata.Summary
     - entities: doc.Metadata.Entities (as JSON array string or directly if Qdrant supports)
   - Use client.Upsert with retry wrapper

2. UpsertChunks(ctx, chunks []*Chunk) error
   - Batch upsert for efficiency (batch size 100)
   - Each chunk becomes a point with:
     - type: "chunk"
     - parent_doc_id: chunk.ParentDocID
     - chunk_index: chunk.ChunkIndex
     - header_path: chunk.HeaderPath
     - content: chunk.Content
     - path: chunk.Path
     - repository: chunk.Repository
     - Vector from chunk.Embedding
   - Validate embedding dimension (must be VectorDimension) before upsert

3. GetDocument(ctx, id string) (*Document, error)
   - Retrieve point by ID
   - Filter by type="parent" for safety
   - Convert payload back to Document struct
   - Return ErrDocumentNotFound if missing

4. SearchChunks(ctx, embedding []float32, limit int, repository string) ([]*Chunk, error)
   - Vector search using Query API
   - Filter: type="chunk" AND repository=repository (if provided)
   - Return top N chunks sorted by similarity
   - Include payload in response

5. GetCommitSHA(ctx, repository string) (string, error)
   - Get the commit SHA for indexed content from a repository
   - Query any document with repository filter, return commit_sha from payload
   - Used to check if re-indexing is needed

Key patterns from research:
- Use qdrant.NewIDUUID for point IDs
- Use qdrant.NewValueMap for payloads
- Use qdrant.NewVectors for embedding
- Batch upserts in groups of 100 for performance
- Filter with qdrant.NewMatch for exact matches

Example structure:
```go
func (s *QdrantStorage) UpsertDocument(ctx context.Context, doc *Document) error {
    point := &qdrant.PointStruct{
        Id:      qdrant.NewIDUUID(doc.ID),
        Vectors: nil, // No vector for parent
        Payload: qdrant.NewValueMap(map[string]any{
            "type":       "parent",
            "content":    doc.Content,
            "path":       doc.Metadata.Path,
            // ... other fields
        }),
    }
    return s.upsertWithRetry(ctx, []*qdrant.PointStruct{point})
}
```
  </action>
  <verify>
`go build ./internal/storage/...` compiles. All new methods are exported and have correct signatures matching Document/Chunk types from models.go.
  </verify>
  <done>
All storage operations implemented: upsert documents, upsert chunks, get document by ID, search chunks by vector, get commit SHA. Operations use retry wrapper and validate inputs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create integration test proving persistence</name>
  <files>internal/storage/qdrant_test.go</files>
  <action>
Create integration tests that prove the phase success criteria - data persists across restarts.

Create internal/storage/qdrant_test.go with tests that require a running Qdrant instance (use build tag or skip if not available):

1. TestDocumentRoundTrip
   - Create QdrantStorage, EnsureCollection
   - Create Document with all metadata fields populated
   - UpsertDocument
   - GetDocument by ID
   - Assert all fields match

2. TestChunkSearchRoundTrip
   - UpsertDocument (parent)
   - Create Chunk with fake embedding (1536 zeros or random floats)
   - UpsertChunks
   - SearchChunks with same embedding
   - Assert chunk is found with correct parent_doc_id

3. TestCommitSHATracking
   - Upsert document with CommitSHA "abc123"
   - GetCommitSHA for repository
   - Assert returns "abc123"

4. TestPersistence (the key test!)
   - Upsert a document with unique ID
   - Close the storage connection
   - Create NEW QdrantStorage connection
   - GetDocument with same ID
   - Assert document content matches
   - This proves STOR-04: data persists across "restarts"

Test setup:
- Use test flag or environment variable to enable integration tests
- Skip if Qdrant not running (check with health check first)
- Clean up test data after each test (or use unique IDs)

Example:
```go
// +build integration

func TestPersistence(t *testing.T) {
    // Skip if Qdrant not running
    storage, err := NewQdrantStorage("localhost", 6334)
    if err != nil {
        t.Skip("Qdrant not available")
    }
    defer storage.Close()
    storage.EnsureCollection(context.Background())

    // Create and store document
    docID := uuid.New().String()
    doc := &Document{
        ID:      docID,
        Content: "# Test Document\n\nThis is test content.",
        Metadata: DocumentMetadata{
            Path:       "test/persistence.md",
            Repository: "test/repo",
            CommitSHA:  "test123",
            IndexedAt:  time.Now(),
        },
    }
    err = storage.UpsertDocument(context.Background(), doc)
    require.NoError(t, err)

    // Close connection
    storage.Close()

    // Reconnect (simulates restart)
    storage2, err := NewQdrantStorage("localhost", 6334)
    require.NoError(t, err)
    defer storage2.Close()

    // Retrieve and verify
    retrieved, err := storage2.GetDocument(context.Background(), docID)
    require.NoError(t, err)
    assert.Equal(t, doc.Content, retrieved.Content)
    assert.Equal(t, doc.Metadata.CommitSHA, retrieved.Metadata.CommitSHA)
}
```
  </action>
  <verify>
With Qdrant running: `go test -tags=integration ./internal/storage/...` passes all tests. TestPersistence specifically proves data survives reconnection.
  </verify>
  <done>
Integration tests prove: document roundtrip works, chunk search works, commit SHA tracking works, and data persists across storage reconnections (STOR-04 verified).
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./internal/storage/...` compiles
2. `go test ./internal/storage/...` passes (unit tests, if any)
3. `go test -tags=integration ./internal/storage/...` passes (with Qdrant running)
4. TestPersistence specifically proves data survives disconnection/reconnection
5. All STOR requirements are satisfied:
   - STOR-01: Embeddings stored (via UpsertChunks)
   - STOR-02: Full content stored (via UpsertDocument)
   - STOR-03: Metadata stored (all fields in Document/Chunk)
   - STOR-04: Persistence proven (TestPersistence)
   - STOR-05: Commit SHA tracked (GetCommitSHA)
</verification>

<success_criteria>
- Document upsert/retrieval works with all metadata
- Chunk upsert/search works with embeddings
- Commit SHA is queryable per repository
- Integration test proves data persists across storage reconnection
- All STOR-01 through STOR-05 requirements are satisfied
- Phase 1 complete: storage foundation ready for Phase 2 (document processing)
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-03-SUMMARY.md`
</output>
