---
phase: 01-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - docker-compose.yml
  - internal/storage/models.go
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Go module initializes and dependencies install without errors"
    - "Qdrant container starts and accepts connections on port 6334"
    - "Storage data structures represent documents and chunks with all required metadata"
  artifacts:
    - path: "go.mod"
      provides: "Go module definition with Qdrant and OpenAI dependencies"
      contains: "github.com/qdrant/go-client"
    - path: "docker-compose.yml"
      provides: "Qdrant container with persistent volume"
      contains: "qdrant/qdrant"
    - path: "internal/storage/models.go"
      provides: "Document and chunk data structures"
      exports: ["Document", "Chunk", "DocumentMetadata"]
  key_links:
    - from: "go.mod"
      to: "github.com/qdrant/go-client"
      via: "dependency declaration"
      pattern: "github.com/qdrant/go-client"
    - from: "docker-compose.yml"
      to: "qdrant_data volume"
      via: "volume mount"
      pattern: "qdrant_data:/qdrant/storage"
---

<objective>
Set up Go project foundation and define storage data structures for the EINO documentation MCP server.

Purpose: Establish the project skeleton with all required dependencies and data models that subsequent plans will build upon. This is the foundation layer - nothing else can proceed without a working Go module and clear data structures.

Output: Working Go project with Qdrant running locally in Docker, ready for client integration.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go project with dependencies</name>
  <files>go.mod, go.sum, .env.example</files>
  <action>
Initialize Go module for the EINO MCP server project:

1. Create go.mod with module path `github.com/user/eino-mcp` (or appropriate path)
2. Add required dependencies:
   - github.com/qdrant/go-client (official Qdrant Go client)
   - github.com/cenkalti/backoff/v4 (exponential backoff for retries)
   - github.com/google/uuid (UUID generation for point IDs)

Note: Do NOT add openai-go yet - embeddings are Phase 2 (Document Processing). Phase 1 is storage infrastructure only.

3. Create .env.example with:
   - QDRANT_HOST=localhost
   - QDRANT_PORT=6334
   - QDRANT_DATA_PATH=./qdrant_data

Run `go mod tidy` to resolve dependencies.
  </action>
  <verify>
`go mod tidy` completes without errors. `go list -m all` shows qdrant/go-client, cenkalti/backoff/v4, google/uuid.
  </verify>
  <done>
Go module exists with all storage dependencies resolved. .env.example documents required configuration.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose for local Qdrant</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml to run Qdrant locally for development:

```yaml
version: '3.8'

services:
  qdrant:
    image: qdrant/qdrant:v1.16.0
    ports:
      - "6333:6333"  # REST API
      - "6334:6334"  # gRPC (primary - use this)
    volumes:
      - qdrant_data:/qdrant/storage
    environment:
      - QDRANT__LOG_LEVEL=INFO
    ulimits:
      nofile:
        soft: 10000
        hard: 10000

volumes:
  qdrant_data:
```

Key decisions from research:
- Use gRPC port 6334 (2-3x faster than REST)
- Named volume `qdrant_data` (not bind mount - avoids WSL filesystem issues)
- Set ulimit for file descriptors (prevents "Too many files open" errors)
- Pin to specific version for reproducibility
  </action>
  <verify>
`docker compose up -d` starts Qdrant. `curl http://localhost:6333/health` returns healthy status. `docker compose down && docker compose up -d` and Qdrant still has any previously created collections (persistence works).
  </verify>
  <done>
Qdrant runs locally with persistent storage. Container survives restarts without data loss.
  </done>
</task>

<task type="auto">
  <name>Task 3: Define storage data models</name>
  <files>internal/storage/models.go</files>
  <action>
Create data structures that represent documents and chunks stored in Qdrant.

From CONTEXT.md decisions:
- Full markdown content stored inline in payload
- Both parent documents (full docs) and chunks (with embeddings) stored
- Chunks have parent_doc_id linking to full document
- Timestamps in RFC3339 format
- Source repository as full path
- File path relative to docs root

Create internal/storage/models.go with:

```go
package storage

import "time"

// Document represents a full markdown document stored in Qdrant.
// Documents have no embedding vector - they exist for full-content retrieval.
type Document struct {
    ID         string            // UUID
    Content    string            // Full markdown content
    Metadata   DocumentMetadata
}

// DocumentMetadata contains indexing metadata for a document.
type DocumentMetadata struct {
    Path       string    // Relative path: "getting-started/installation.md"
    URL        string    // GitHub raw URL for source
    Repository string    // Full repo path: "cloudwego/eino"
    CommitSHA  string    // Git commit SHA when indexed
    IndexedAt  time.Time // When this version was indexed
    Summary    string    // LLM-generated summary (populated in Phase 2)
    Entities   []string  // Extracted functions/methods (populated in Phase 2)
}

// Chunk represents a document section with an embedding vector.
// Chunks are used for semantic search, then parent document is retrieved.
type Chunk struct {
    ID           string    // UUID
    ParentDocID  string    // Links to parent Document.ID
    ChunkIndex   int       // Position in document (0, 1, 2...)
    HeaderPath   string    // Section hierarchy: "Installation > Prerequisites"
    Content      string    // Chunk text content
    Path         string    // Same as parent document path (for filtering)
    Repository   string    // Same as parent (for filtering)
    Embedding    []float32 // 1536-dim vector (text-embedding-3-small)
}

// CollectionName is the single Qdrant collection for all documents.
const CollectionName = "documents"

// VectorDimension is the embedding size for text-embedding-3-small.
const VectorDimension = 1536
```

Design notes:
- Separate Document and Chunk types for clarity
- Chunk duplicates path/repository for efficient Qdrant filtering without joins
- Embedding field on Chunk only (documents don't have vectors)
- Constants for collection name and dimension ensure consistency
  </action>
  <verify>
`go build ./...` compiles without errors. Types are exported (capitalized).
  </verify>
  <done>
Storage models define the data contract for documents and chunks. Parent-child relationship is clear. All metadata fields from requirements (STOR-03, STOR-05) are represented.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go mod tidy && go build ./...` succeeds
2. `docker compose up -d` starts Qdrant on port 6334
3. `curl http://localhost:6333/health` returns OK
4. internal/storage/models.go exports Document, Chunk, DocumentMetadata types
</verification>

<success_criteria>
- Go project compiles with all storage dependencies
- Qdrant container runs locally with persistent volume
- Data models represent documents, chunks, and all required metadata fields
- Foundation is ready for Qdrant client implementation (Plan 02)
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-01-SUMMARY.md`
</output>
