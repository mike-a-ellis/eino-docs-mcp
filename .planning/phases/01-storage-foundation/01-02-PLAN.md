---
phase: 01-storage-foundation
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - internal/storage/qdrant.go
  - internal/storage/errors.go
autonomous: true

must_haves:
  truths:
    - "Qdrant client connects and validates connectivity on startup"
    - "Collection is auto-created with correct vector config if missing"
    - "Payload indexes exist for all filterable fields (path, repository, commit_sha, type)"
    - "Connection failures retry with exponential backoff"
    - "Health check method reports Qdrant status"
  artifacts:
    - path: "internal/storage/qdrant.go"
      provides: "Qdrant client wrapper with connection, health, and collection management"
      exports: ["QdrantStorage", "NewQdrantStorage", "Health", "EnsureCollection"]
      min_lines: 100
    - path: "internal/storage/errors.go"
      provides: "Storage error types for error handling"
      exports: ["ErrQdrantUnreachable", "ErrCollectionNotFound"]
  key_links:
    - from: "internal/storage/qdrant.go"
      to: "github.com/qdrant/go-client"
      via: "client initialization"
      pattern: "qdrant\\.NewClient"
    - from: "internal/storage/qdrant.go"
      to: "github.com/cenkalti/backoff"
      via: "retry wrapper"
      pattern: "backoff\\.Retry"
---

<objective>
Implement Qdrant client wrapper with connection management, health checking, and collection setup.

Purpose: Create the core infrastructure layer that all storage operations will use. This wrapper handles the "plumbing" - connection, retries, collection setup - so document operations (Plan 03) can focus on business logic.

Output: QdrantStorage type that connects to Qdrant, ensures collection exists with indexes, and provides health checks.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/01-storage-foundation/01-RESEARCH.md
@.planning/phases/01-storage-foundation/01-CONTEXT.md
@.planning/phases/01-storage-foundation/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement Qdrant client wrapper with health checks</name>
  <files>internal/storage/qdrant.go, internal/storage/errors.go</files>
  <action>
Create the QdrantStorage type that wraps the Qdrant Go client.

Create internal/storage/errors.go first:
```go
package storage

import "errors"

var (
    ErrQdrantUnreachable  = errors.New("qdrant server unreachable")
    ErrCollectionNotFound = errors.New("collection not found")
    ErrDimensionMismatch  = errors.New("embedding dimension mismatch")
)
```

Create internal/storage/qdrant.go with:

1. QdrantStorage struct holding the Qdrant client
2. NewQdrantStorage(host string, port int) constructor that:
   - Creates Qdrant client using gRPC (port 6334)
   - Performs health check with retry on startup
   - Returns error if Qdrant unreachable after retries (fail-fast)
3. Health(ctx context.Context) error method for ongoing health checks
4. Close() method to clean up connection

Key patterns from research:
- Use qdrant.NewClient with Config{Host, Port}
- Health check via client.HealthCheck(ctx)
- Wrap connection attempts with exponential backoff (cenkalti/backoff/v4)
- Initial interval 500ms, max interval 10s, max elapsed 30s
- Don't retry client errors (4xx equivalent) - wrap with backoff.Permanent

Configuration from CONTEXT.md:
- Read host/port from constructor params (caller reads from env)
- Retry with exponential backoff (3 attempts)
- Fail startup if Qdrant unreachable

Example structure:
```go
type QdrantStorage struct {
    client *qdrant.Client
    host   string
    port   int
}

func NewQdrantStorage(host string, port int) (*QdrantStorage, error) {
    // Create client, health check with retry, return error if unreachable
}

func (s *QdrantStorage) Health(ctx context.Context) error {
    // Single health check call
}

func (s *QdrantStorage) Close() error {
    return s.client.Close()
}
```
  </action>
  <verify>
`go build ./internal/storage/...` compiles. With Qdrant running (`docker compose up -d`), calling NewQdrantStorage("localhost", 6334) succeeds. With Qdrant stopped, NewQdrantStorage returns ErrQdrantUnreachable after retry attempts.
  </verify>
  <done>
QdrantStorage connects to Qdrant with health validation. Retries handle transient failures. Startup fails fast if Qdrant is truly unreachable.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement collection auto-creation with payload indexes</name>
  <files>internal/storage/qdrant.go</files>
  <action>
Add EnsureCollection method that creates the documents collection if it doesn't exist.

Add to internal/storage/qdrant.go:

1. EnsureCollection(ctx context.Context) error method that:
   - Lists existing collections
   - If "documents" collection exists, returns nil (idempotent)
   - If not, creates collection with VectorParams:
     - Size: 1536 (text-embedding-3-small dimension from models.go constant)
     - Distance: Cosine
   - Creates payload indexes for filterable fields (CRITICAL for performance):
     - "path" - FieldTypeKeyword
     - "repository" - FieldTypeKeyword
     - "commit_sha" - FieldTypeKeyword
     - "type" - FieldTypeKeyword (to distinguish "parent" vs "chunk")
     - "parent_doc_id" - FieldTypeKeyword (for chunk lookups)

From research pitfalls:
- MUST create payload indexes or filtering becomes 10-100x slower
- Use FieldType_FieldTypeKeyword for all string fields

Example:
```go
func (s *QdrantStorage) EnsureCollection(ctx context.Context) error {
    // Check if exists
    collections, err := s.client.ListCollections(ctx)
    // ... check if CollectionName in list

    // Create collection
    err = s.client.CreateCollection(ctx, &qdrant.CreateCollection{
        CollectionName: CollectionName,
        VectorsConfig: qdrant.NewVectorsConfig(&qdrant.VectorParams{
            Size:     VectorDimension,
            Distance: qdrant.Distance_Cosine,
        }),
    })

    // Create indexes
    for _, field := range []string{"path", "repository", "commit_sha", "type", "parent_doc_id"} {
        s.client.CreateFieldIndex(ctx, &qdrant.CreateFieldIndexCollection{
            CollectionName: CollectionName,
            FieldName:      field,
            FieldType:      qdrant.FieldType_FieldTypeKeyword.Enum(),
        })
    }
}
```

2. Also add a helper method createPayloadIndexes(ctx) for clarity

3. Optionally add ClearCollection(ctx) for re-indexing scenarios (from CONTEXT.md decision)
  </action>
  <verify>
With fresh Qdrant (no collections), EnsureCollection creates "documents" collection. Calling EnsureCollection again is idempotent (no error). Collection has correct vector dimension (1536) and payload indexes.
  </verify>
  <done>
Collection auto-creation works. Payload indexes are created for all filterable fields. Collection setup is idempotent and safe to call on every startup.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `go build ./internal/storage/...` compiles
2. With Qdrant running: NewQdrantStorage succeeds, Health() returns nil
3. EnsureCollection creates collection with indexes on fresh Qdrant
4. Stopping Qdrant causes NewQdrantStorage to fail after retries
5. Collection info shows 1536-dimension vectors with cosine distance
</verification>

<success_criteria>
- QdrantStorage type connects to Qdrant with retry logic
- Health check validates Qdrant connectivity
- Collection auto-created with correct vector config
- All filterable fields have payload indexes
- Startup fails fast if Qdrant unreachable
- Ready for document storage operations (Plan 03)
</success_criteria>

<output>
After completion, create `.planning/phases/01-storage-foundation/01-02-SUMMARY.md`
</output>
