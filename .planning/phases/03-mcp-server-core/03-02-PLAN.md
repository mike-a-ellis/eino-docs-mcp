---
phase: 03-mcp-server-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/storage/qdrant.go
  - internal/storage/models.go
  - internal/storage/qdrant_test.go
autonomous: true

must_haves:
  truths:
    - "SearchChunks returns similarity scores alongside chunk data"
    - "ListDocumentPaths returns all unique document paths in the index"
    - "GetDocumentByPath retrieves a document by its path field"
  artifacts:
    - path: "internal/storage/qdrant.go"
      provides: "Enhanced storage methods with scores and path operations"
      exports: ["SearchChunksWithScores", "ListDocumentPaths", "GetDocumentByPath"]
    - path: "internal/storage/models.go"
      provides: "ScoredChunk type with score field"
      contains: "type ScoredChunk"
  key_links:
    - from: "internal/storage/qdrant.go"
      to: "qdrant.ScoredPoint"
      via: "Query response parsing"
      pattern: "result\\.Score"
---

<objective>
Enhance storage layer with score retrieval, document path listing, and path-based lookup.

Purpose: Provide the data access methods needed by MCP tool handlers (scores for relevance ranking, path listing for list_docs, path lookup for fetch_doc).
Output: Storage layer with SearchChunksWithScores, ListDocumentPaths, and GetDocumentByPath methods.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-storage-foundation/01-03-SUMMARY.md
@internal/storage/qdrant.go
@internal/storage/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ScoredChunk type and SearchChunksWithScores method</name>
  <files>internal/storage/models.go, internal/storage/qdrant.go</files>
  <action>
1. In `internal/storage/models.go`, add ScoredChunk type:

```go
// ScoredChunk wraps a Chunk with its similarity score from vector search.
type ScoredChunk struct {
    *Chunk
    Score float64 // Similarity score (0-1, higher is more similar)
}
```

2. In `internal/storage/qdrant.go`, add new method `SearchChunksWithScores`:

```go
// SearchChunksWithScores performs vector similarity search on chunks.
// Returns top N chunks with similarity scores, ordered by score descending.
// This replaces SearchChunks for MCP handlers that need relevance scores.
func (s *QdrantStorage) SearchChunksWithScores(ctx context.Context, embedding []float32, limit int, repository string) ([]*ScoredChunk, error) {
    if len(embedding) != VectorDimension {
        return nil, fmt.Errorf("%w: query has %d dimensions, expected %d",
            ErrDimensionMismatch, len(embedding), VectorDimension)
    }

    // Build filter conditions
    must := []*qdrant.Condition{
        qdrant.NewMatch("type", "chunk"),
    }
    if repository != "" {
        must = append(must, qdrant.NewMatch("repository", repository))
    }

    filter := &qdrant.Filter{
        Must: must,
    }

    // Perform vector search using named vector "content"
    vectorName := "content"
    results, err := s.client.Query(ctx, &qdrant.QueryPoints{
        CollectionName: CollectionName,
        Query:          qdrant.NewQuery(embedding...),
        Using:          &vectorName,
        Filter:         filter,
        Limit:          qdrant.PtrOf(uint64(limit)),
        WithPayload:    qdrant.NewWithPayload(true),
        WithVectors:    qdrant.NewWithVectors(false), // Don't need vectors in response
    })
    if err != nil {
        return nil, fmt.Errorf("failed to search chunks: %w", err)
    }

    scoredChunks := make([]*ScoredChunk, 0, len(results))
    for _, result := range results {
        payload := result.Payload

        chunk := &Chunk{
            ID:          result.Id.GetUuid(),
            ParentDocID: payload["parent_doc_id"].GetStringValue(),
            ChunkIndex:  int(payload["chunk_index"].GetIntegerValue()),
            HeaderPath:  payload["header_path"].GetStringValue(),
            Content:     payload["content"].GetStringValue(),
            Path:        payload["path"].GetStringValue(),
            Repository:  payload["repository"].GetStringValue(),
        }

        scoredChunks = append(scoredChunks, &ScoredChunk{
            Chunk: chunk,
            Score: float64(result.Score), // Qdrant returns float32, convert to float64
        })
    }

    return scoredChunks, nil
}
```

Note: Qdrant Query response includes `Score` field on each ScoredPoint. The score is cosine similarity (0-1 range for normalized vectors).
  </action>
  <verify>`go build ./internal/storage/...` succeeds; write simple test to verify score is populated</verify>
  <done>ScoredChunk type exists, SearchChunksWithScores returns chunks with scores</done>
</task>

<task type="auto">
  <name>Task 2: Add ListDocumentPaths and GetDocumentByPath methods</name>
  <files>internal/storage/qdrant.go, internal/storage/qdrant_test.go</files>
  <action>
1. Add `ListDocumentPaths` method to `internal/storage/qdrant.go`:

```go
// ListDocumentPaths returns all unique document paths in the index.
// Uses Scroll API to iterate through all parent documents.
func (s *QdrantStorage) ListDocumentPaths(ctx context.Context, repository string) ([]string, error) {
    var paths []string
    var offset *qdrant.PointId

    // Build filter for parent documents
    must := []*qdrant.Condition{
        qdrant.NewMatch("type", "parent"),
    }
    if repository != "" {
        must = append(must, qdrant.NewMatch("repository", repository))
    }

    filter := &qdrant.Filter{
        Must: must,
    }

    // Scroll through all parent documents
    for {
        results, err := s.client.Scroll(ctx, &qdrant.ScrollPoints{
            CollectionName: CollectionName,
            Filter:         filter,
            Limit:          qdrant.PtrOf(uint32(100)), // Batch size
            Offset:         offset,
            WithPayload:    qdrant.NewWithPayloadInclude("path"), // Only need path field
        })
        if err != nil {
            return nil, fmt.Errorf("failed to scroll documents: %w", err)
        }

        if len(results) == 0 {
            break
        }

        for _, result := range results {
            if path := result.Payload["path"].GetStringValue(); path != "" {
                paths = append(paths, path)
            }
        }

        // Get offset for next page (last point ID)
        offset = results[len(results)-1].Id
    }

    // Sort paths alphabetically for consistent ordering
    sort.Strings(paths)
    return paths, nil
}
```

2. Add `GetDocumentByPath` method:

```go
// GetDocumentByPath retrieves a parent document by its path.
// Returns ErrDocumentNotFound if no document exists with the given path.
func (s *QdrantStorage) GetDocumentByPath(ctx context.Context, path string, repository string) (*Document, error) {
    // Build filter for parent document with matching path
    must := []*qdrant.Condition{
        qdrant.NewMatch("type", "parent"),
        qdrant.NewMatch("path", path),
    }
    if repository != "" {
        must = append(must, qdrant.NewMatch("repository", repository))
    }

    filter := &qdrant.Filter{
        Must: must,
    }

    results, err := s.client.Scroll(ctx, &qdrant.ScrollPoints{
        CollectionName: CollectionName,
        Filter:         filter,
        Limit:          qdrant.PtrOf(uint32(1)),
        WithPayload:    qdrant.NewWithPayload(true),
    })
    if err != nil {
        return nil, fmt.Errorf("failed to query document by path: %w", err)
    }

    if len(results) == 0 {
        return nil, ErrDocumentNotFound
    }

    point := results[0]
    payload := point.Payload

    // Parse indexed_at timestamp
    indexedAt, err := time.Parse(time.RFC3339, payload["indexed_at"].GetStringValue())
    if err != nil {
        indexedAt = time.Time{} // Use zero time if parse fails
    }

    // Extract entities
    var entities []string
    if entitiesVal, ok := payload["entities"]; ok && entitiesVal.GetListValue() != nil {
        for _, val := range entitiesVal.GetListValue().Values {
            entities = append(entities, val.GetStringValue())
        }
    }

    doc := &Document{
        ID:      point.Id.GetUuid(),
        Content: payload["content"].GetStringValue(),
        Metadata: DocumentMetadata{
            Path:       payload["path"].GetStringValue(),
            URL:        payload["url"].GetStringValue(),
            Repository: payload["repository"].GetStringValue(),
            CommitSHA:  payload["commit_sha"].GetStringValue(),
            IndexedAt:  indexedAt,
            Summary:    payload["summary"].GetStringValue(),
            Entities:   entities,
        },
    }

    return doc, nil
}
```

3. Add `import "sort"` at the top of the file.

4. Add tests in `internal/storage/qdrant_test.go`:
- Test that SearchChunksWithScores returns scores > 0 for matching chunks
- Test that ListDocumentPaths returns all document paths
- Test that GetDocumentByPath retrieves correct document
- Test that GetDocumentByPath returns ErrDocumentNotFound for invalid path
  </action>
  <verify>`go test ./internal/storage/...` passes (requires Qdrant running)</verify>
  <done>Both methods implemented and tested</done>
</task>

</tasks>

<verification>
1. `go build ./internal/storage/...` succeeds
2. `go test ./internal/storage/...` passes with new tests
3. SearchChunksWithScores returns scores in 0-1 range
4. ListDocumentPaths returns sorted paths
5. GetDocumentByPath returns document or ErrDocumentNotFound
</verification>

<success_criteria>
- ScoredChunk type with Score field exists
- SearchChunksWithScores returns chunks with similarity scores
- ListDocumentPaths returns all document paths alphabetically sorted
- GetDocumentByPath retrieves document by path or returns error
- All tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server-core/03-02-SUMMARY.md`
</output>
