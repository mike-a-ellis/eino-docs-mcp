---
phase: 03-mcp-server-core
plan: 03
type: execute
wave: 2
depends_on: ["03-01", "03-02"]
files_modified:
  - internal/mcp/server.go
  - internal/mcp/handlers.go
  - cmd/mcp-server/main.go
autonomous: true

must_haves:
  truths:
    - "search_docs tool returns relevant documents with scores when queried"
    - "fetch_doc tool returns full markdown content for valid paths"
    - "fetch_doc tool returns informative error for invalid paths"
    - "list_docs tool returns all available document paths"
    - "Server connects to Qdrant and generates embeddings on startup"
  artifacts:
    - path: "internal/mcp/handlers.go"
      provides: "Tool handler implementations"
      exports: ["makeSearchHandler", "makeFetchHandler", "makeListHandler"]
    - path: "cmd/mcp-server/main.go"
      provides: "Complete server startup with dependencies"
      contains: ["NewQdrantStorage", "NewEmbedder"]
  key_links:
    - from: "internal/mcp/handlers.go"
      to: "internal/storage/qdrant.go"
      via: "Storage method calls"
      pattern: "storage\\.SearchChunksWithScores|storage\\.GetDocumentByPath|storage\\.ListDocumentPaths"
    - from: "internal/mcp/handlers.go"
      to: "internal/embedding/embedder.go"
      via: "Query embedding generation"
      pattern: "embedder\\.GenerateEmbeddings"
    - from: "cmd/mcp-server/main.go"
      to: "internal/storage/qdrant.go"
      via: "Storage initialization"
      pattern: "storage\\.NewQdrantStorage"
---

<objective>
Implement MCP tool handlers connecting protocol layer to storage and embedding services.

Purpose: Complete the MCP server so AI agents can search, fetch, and list EINO documentation.
Output: Fully functional MCP server with working search_docs, fetch_doc, and list_docs tools.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-server-core/03-RESEARCH.md
@.planning/phases/03-mcp-server-core/03-CONTEXT.md
@.planning/phases/03-mcp-server-core/03-01-SUMMARY.md
@.planning/phases/03-mcp-server-core/03-02-SUMMARY.md
@internal/mcp/server.go
@internal/mcp/types.go
@internal/storage/qdrant.go
@internal/storage/models.go
@internal/embedding/embedder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement tool handlers with storage integration</name>
  <files>internal/mcp/handlers.go</files>
  <action>
Create `internal/mcp/handlers.go` with handler factory functions that close over storage and embedder dependencies.

**search_docs handler:**
```go
package mcp

import (
    "context"
    "fmt"

    "github.com/modelcontextprotocol/go-sdk/mcp"
    "github.com/bull/eino-mcp-server/internal/embedding"
    "github.com/bull/eino-mcp-server/internal/storage"
)

const defaultRepository = "cloudwego/cloudwego.github.io"

// makeSearchHandler creates the search_docs tool handler.
// Search flow:
// 1. Generate embedding for query text
// 2. Search chunks with vector similarity (limit * 3 to get enough parents)
// 3. Filter by minimum score threshold
// 4. Deduplicate by parent document (keep highest-scoring chunk per doc)
// 5. Fetch parent document metadata for each unique doc
// 6. Return up to MaxResults documents with metadata (not content)
func makeSearchHandler(storage *storage.QdrantStorage, embedder *embedding.Embedder) func(
    context.Context, *mcp.CallToolRequest, SearchDocsInput,
) (*mcp.CallToolResult, SearchDocsOutput, error) {
    return func(ctx context.Context, req *mcp.CallToolRequest, input SearchDocsInput) (
        *mcp.CallToolResult, SearchDocsOutput, error,
    ) {
        // Apply defaults
        maxResults := input.MaxResults
        if maxResults <= 0 {
            maxResults = 5
        }
        minScore := input.MinScore
        if minScore <= 0 {
            minScore = 0.5
        }

        // Generate embedding for query
        embeddings, err := embedder.GenerateEmbeddings(ctx, []string{input.Query})
        if err != nil {
            return nil, SearchDocsOutput{}, fmt.Errorf("failed to embed query: %w", err)
        }
        queryEmbedding := embeddings[0]

        // Search chunks (request 3x to ensure enough unique documents after dedup)
        chunks, err := storage.SearchChunksWithScores(ctx, queryEmbedding, maxResults*3, defaultRepository)
        if err != nil {
            return nil, SearchDocsOutput{}, fmt.Errorf("search failed: %w", err)
        }

        // Deduplicate by parent document, keeping highest score per doc
        docScores := make(map[string]float64)      // docID -> highest score
        docIDs := make([]string, 0)                 // preserve order
        for _, chunk := range chunks {
            if chunk.Score < minScore {
                continue // Below threshold
            }
            if existing, seen := docScores[chunk.ParentDocID]; !seen || chunk.Score > existing {
                if !seen {
                    docIDs = append(docIDs, chunk.ParentDocID)
                }
                docScores[chunk.ParentDocID] = chunk.Score
            }
        }

        // Limit to maxResults
        if len(docIDs) > maxResults {
            docIDs = docIDs[:maxResults]
        }

        // Fetch document metadata for each unique document
        results := make([]SearchResult, 0, len(docIDs))
        for _, docID := range docIDs {
            doc, err := storage.GetDocument(ctx, docID)
            if err != nil {
                continue // Skip documents that fail to load
            }
            results = append(results, SearchResult{
                Path:      doc.Metadata.Path,
                Score:     docScores[docID],
                Summary:   doc.Metadata.Summary,
                Entities:  doc.Metadata.Entities,
                UpdatedAt: doc.Metadata.IndexedAt,
            })
        }

        if len(results) == 0 {
            return nil, SearchDocsOutput{
                Results: []SearchResult{},
                Message: "No matching documents found. Try broader search terms.",
            }, nil
        }

        return nil, SearchDocsOutput{Results: results}, nil
    }
}
```

**fetch_doc handler:**
```go
// makeFetchHandler creates the fetch_doc tool handler.
// Retrieves full document content by path.
// Prepends source header: <!-- Source: path/to/doc.md -->
func makeFetchHandler(storage *storage.QdrantStorage) func(
    context.Context, *mcp.CallToolRequest, FetchDocInput,
) (*mcp.CallToolResult, FetchDocOutput, error) {
    return func(ctx context.Context, req *mcp.CallToolRequest, input FetchDocInput) (
        *mcp.CallToolResult, FetchDocOutput, error,
    ) {
        doc, err := storage.GetDocumentByPath(ctx, input.Path, defaultRepository)
        if err != nil {
            // Return helpful response for not found
            if err == storage.ErrDocumentNotFound {
                return nil, FetchDocOutput{
                    Found: false,
                    Path:  input.Path,
                }, nil
            }
            return nil, FetchDocOutput{}, fmt.Errorf("failed to fetch document: %w", err)
        }

        // Prepend source header
        content := fmt.Sprintf("<!-- Source: %s -->\n\n%s", doc.Metadata.Path, doc.Content)

        return nil, FetchDocOutput{
            Content:   content,
            Path:      doc.Metadata.Path,
            Summary:   doc.Metadata.Summary,
            UpdatedAt: doc.Metadata.IndexedAt,
            Found:     true,
        }, nil
    }
}
```

**list_docs handler:**
```go
// makeListHandler creates the list_docs tool handler.
// Returns all available document paths.
func makeListHandler(storage *storage.QdrantStorage) func(
    context.Context, *mcp.CallToolRequest, ListDocsInput,
) (*mcp.CallToolResult, ListDocsOutput, error) {
    return func(ctx context.Context, req *mcp.CallToolRequest, input ListDocsInput) (
        *mcp.CallToolResult, ListDocsOutput, error,
    ) {
        paths, err := storage.ListDocumentPaths(ctx, defaultRepository)
        if err != nil {
            return nil, ListDocsOutput{}, fmt.Errorf("failed to list documents: %w", err)
        }

        return nil, ListDocsOutput{
            Paths: paths,
            Count: len(paths),
        }, nil
    }
}
```
  </action>
  <verify>`go build ./internal/mcp/...` succeeds</verify>
  <done>All three handlers implemented with proper error handling</done>
</task>

<task type="auto">
  <name>Task 2: Wire dependencies and update server initialization</name>
  <files>internal/mcp/server.go, cmd/mcp-server/main.go</files>
  <action>
1. Update `internal/mcp/server.go` to accept and use real dependencies:

```go
package mcp

import (
    "context"

    "github.com/modelcontextprotocol/go-sdk/mcp"
    "github.com/bull/eino-mcp-server/internal/embedding"
    "github.com/bull/eino-mcp-server/internal/storage"
)

// Server wraps the MCP server with dependencies
type Server struct {
    server   *mcp.Server
    storage  *storage.QdrantStorage
    embedder *embedding.Embedder
}

// Config holds server dependencies
type Config struct {
    Storage  *storage.QdrantStorage
    Embedder *embedding.Embedder
}

// NewServer creates configured MCP server with tools registered
func NewServer(cfg *Config) *Server {
    impl := &mcp.Implementation{
        Name:    "eino-documentation-server",
        Version: "v0.1.0",
    }

    server := mcp.NewServer(impl, nil)

    // Register tools with real handlers
    mcp.AddTool(server, &mcp.Tool{
        Name:        "search_docs",
        Description: "Search EINO documentation semantically. Returns metadata for matching documents. Use fetch_doc to get full content.",
    }, makeSearchHandler(cfg.Storage, cfg.Embedder))

    mcp.AddTool(server, &mcp.Tool{
        Name:        "fetch_doc",
        Description: "Retrieve a specific EINO document by path. Returns full markdown content.",
    }, makeFetchHandler(cfg.Storage))

    mcp.AddTool(server, &mcp.Tool{
        Name:        "list_docs",
        Description: "List all available EINO documentation paths.",
    }, makeListHandler(cfg.Storage))

    return &Server{
        server:   server,
        storage:  cfg.Storage,
        embedder: cfg.Embedder,
    }
}

// Run starts the server with stdio transport (blocks until client disconnects)
func (s *Server) Run(ctx context.Context) error {
    return s.server.Run(ctx, mcp.NewStdioTransport())
}
```

2. Update `cmd/mcp-server/main.go` to initialize all dependencies:

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"

    "github.com/bull/eino-mcp-server/internal/embedding"
    mcpserver "github.com/bull/eino-mcp-server/internal/mcp"
    "github.com/bull/eino-mcp-server/internal/storage"
)

func main() {
    // Create context that cancels on SIGTERM/SIGINT
    ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
    defer cancel()

    // Configuration from environment
    qdrantHost := getEnv("QDRANT_HOST", "localhost")
    qdrantPort := getEnvInt("QDRANT_PORT", 6334)

    // Initialize storage
    store, err := storage.NewQdrantStorage(qdrantHost, qdrantPort)
    if err != nil {
        log.Fatalf("failed to connect to Qdrant: %v", err)
    }
    defer store.Close()

    // Ensure collection exists
    if err := store.EnsureCollection(ctx); err != nil {
        log.Fatalf("failed to ensure collection: %v", err)
    }

    // Initialize embedding client
    embeddingClient, err := embedding.NewClient()
    if err != nil {
        log.Fatalf("failed to create embedding client: %v", err)
    }
    embedder := embedding.NewEmbedder(embeddingClient, 0) // Use default batch size

    // Create and run server
    server := mcpserver.NewServer(&mcpserver.Config{
        Storage:  store,
        Embedder: embedder,
    })

    log.Println("Starting EINO Documentation MCP Server...")
    if err := server.Run(ctx); err != nil {
        log.Printf("server error: %v", err)
        os.Exit(1)
    }
}

func getEnv(key, defaultValue string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return defaultValue
}

func getEnvInt(key string, defaultValue int) int {
    if v := os.Getenv(key); v != "" {
        var i int
        if _, err := fmt.Sscanf(v, "%d", &i); err == nil {
            return i
        }
    }
    return defaultValue
}
```

Note: Add `"fmt"` to imports for getEnvInt.
  </action>
  <verify>`go build ./cmd/mcp-server/...` succeeds; start server with Qdrant running and test tools</verify>
  <done>Server initializes storage and embedder, tools are fully functional</done>
</task>

<task type="auto">
  <name>Task 3: Manual integration test with MCP Inspector</name>
  <files>N/A (testing)</files>
  <action>
Test the MCP server end-to-end:

1. Ensure Qdrant is running:
   ```bash
   docker compose up -d
   ```

2. Ensure documents are indexed (run indexer if needed):
   ```bash
   # If no indexer CLI exists yet, skip this - Phase 4 will add it
   # For now, verify collection has documents:
   curl -s http://localhost:6333/collections/documents | jq '.result.points_count'
   ```

3. Build and start MCP server:
   ```bash
   go build -o mcp-server ./cmd/mcp-server/
   OPENAI_API_KEY=$OPENAI_API_KEY ./mcp-server
   ```

4. Test with manual JSON-RPC (in another terminal):
   ```bash
   # Test initialize
   echo '{"jsonrpc":"2.0","method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}},"id":1}' | ./mcp-server

   # Test list tools
   echo '{"jsonrpc":"2.0","method":"tools/list","params":{},"id":2}' | ./mcp-server

   # Test search_docs
   echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"search_docs","arguments":{"query":"how to create a ChatModel"}},"id":3}' | ./mcp-server

   # Test list_docs
   echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"list_docs","arguments":{}},"id":4}' | ./mcp-server

   # Test fetch_doc (use a path from list_docs)
   echo '{"jsonrpc":"2.0","method":"tools/call","params":{"name":"fetch_doc","arguments":{"path":"getting-started/quick-start.md"}},"id":5}' | ./mcp-server
   ```

5. If MCP Inspector is available:
   ```bash
   npx @anthropics/mcp-inspector ./mcp-server
   ```

Record test results:
- Does search_docs return relevant results with scores?
- Does list_docs return all document paths?
- Does fetch_doc return full markdown with source header?
- Are error cases handled gracefully?
  </action>
  <verify>All three tools respond correctly; search returns documents with scores; fetch returns full content</verify>
  <done>Manual testing confirms all tools work end-to-end</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. Server starts with Qdrant and OpenAI API available
3. search_docs returns relevant documents with scores above threshold
4. fetch_doc returns full markdown content with source header
5. list_docs returns all document paths
6. Error cases return helpful messages (not crashes)
</verification>

<success_criteria>
- All handlers implemented with storage/embedder integration
- Server initializes Qdrant and OpenAI clients on startup
- search_docs performs semantic search and returns deduplicated results
- fetch_doc retrieves documents by path with source header
- list_docs returns sorted list of all paths
- Error responses are informative and actionable
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server-core/03-03-SUMMARY.md`
</output>
