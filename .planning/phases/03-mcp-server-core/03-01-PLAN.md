---
phase: 03-mcp-server-core
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - cmd/mcp-server/main.go
  - internal/mcp/server.go
  - internal/mcp/types.go
autonomous: true

must_haves:
  truths:
    - "MCP server binary compiles and runs without error"
    - "Server responds to MCP initialize handshake"
    - "Three tools are registered: search_docs, fetch_doc, list_docs"
  artifacts:
    - path: "cmd/mcp-server/main.go"
      provides: "MCP server entry point"
      exports: ["main"]
    - path: "internal/mcp/server.go"
      provides: "Server setup with tool registration"
      exports: ["NewServer", "Run"]
    - path: "internal/mcp/types.go"
      provides: "Input/output structs with jsonschema tags"
      exports: ["SearchDocsInput", "SearchDocsOutput", "FetchDocInput", "FetchDocOutput", "ListDocsInput", "ListDocsOutput"]
  key_links:
    - from: "cmd/mcp-server/main.go"
      to: "internal/mcp/server.go"
      via: "NewServer() and Run()"
      pattern: "mcp\\.NewServer|mcp\\.Run"
---

<objective>
Set up MCP server foundation with SDK integration and tool registration.

Purpose: Create the MCP protocol layer that Claude Code can communicate with via stdio transport.
Output: Compilable server binary with three tools registered (handlers stubbed).
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-mcp-server-core/03-RESEARCH.md
@.planning/phases/03-mcp-server-core/03-CONTEXT.md
@internal/storage/models.go
@internal/storage/qdrant.go
@internal/embedding/embedder.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCP SDK dependency and create types</name>
  <files>go.mod, go.sum, internal/mcp/types.go</files>
  <action>
1. Add MCP Go SDK dependency:
   ```bash
   go get github.com/modelcontextprotocol/go-sdk@latest
   ```

2. Create `internal/mcp/types.go` with input/output structs for all three tools.

**SearchDocsInput:**
- Query string (required) - the search query
- MaxResults int (optional, default 5, min 1, max 20) - number of documents to return
- MinScore float64 (optional, default 0.5, min 0, max 1) - minimum relevance threshold

**SearchDocsOutput:**
- Results []SearchResult - array of matching documents
- Message string (optional) - informational message (e.g., "No matching documents found")

**SearchResult:**
- Path string - document path (e.g., "getting-started/installation.md")
- Score float64 - similarity score (0-1)
- Summary string - LLM-generated summary
- Entities []string - extracted functions/methods
- UpdatedAt time.Time - when document was indexed

**FetchDocInput:**
- Path string (required) - document path to retrieve

**FetchDocOutput:**
- Content string - full markdown content with source header prepended
- Path string - document path
- Summary string - document summary
- UpdatedAt time.Time - index timestamp
- Found bool - whether document exists

**ListDocsInput:**
- (no fields - lists all documents)

**ListDocsOutput:**
- Paths []string - all available document paths
- Count int - total number of documents

Use `json` tags with snake_case and `jsonschema` tags for validation:
- `jsonschema:"required"` for required fields
- `jsonschema:"minimum=1,maximum=20,default=5"` for numeric constraints
- `jsonschema:"description=..."` for field documentation
  </action>
  <verify>`go build ./internal/mcp/...` succeeds</verify>
  <done>Types compile, all fields have json and jsonschema tags</done>
</task>

<task type="auto">
  <name>Task 2: Create MCP server setup and main entry point</name>
  <files>internal/mcp/server.go, cmd/mcp-server/main.go</files>
  <action>
1. Create `internal/mcp/server.go` with server factory:

```go
package mcp

import (
    "context"
    "github.com/modelcontextprotocol/go-sdk/mcp"
)

// Server wraps the MCP server with dependencies
type Server struct {
    server  *mcp.Server
    // Storage and embedder will be injected in Plan 03
}

// Config holds server dependencies
type Config struct {
    // Will add Storage and Embedder in Plan 03
}

// NewServer creates configured MCP server with tools registered
func NewServer(cfg *Config) *Server {
    impl := &mcp.Implementation{
        Name:    "eino-documentation-server",
        Version: "v0.1.0",
    }

    server := mcp.NewServer(impl, nil)

    // Register tools (stub handlers for now - will implement in Plan 03)
    mcp.AddTool(server, &mcp.Tool{
        Name:        "search_docs",
        Description: "Search EINO documentation semantically. Returns metadata for matching documents.",
    }, searchDocsStub)

    mcp.AddTool(server, &mcp.Tool{
        Name:        "fetch_doc",
        Description: "Retrieve a specific EINO document by path. Returns full markdown content.",
    }, fetchDocStub)

    mcp.AddTool(server, &mcp.Tool{
        Name:        "list_docs",
        Description: "List all available EINO documentation paths.",
    }, listDocsStub)

    return &Server{server: server}
}

// Run starts the server with stdio transport (blocks until client disconnects)
func (s *Server) Run(ctx context.Context) error {
    return s.server.Run(ctx, mcp.NewStdioTransport())
}
```

2. Add stub handlers that return placeholder responses:

```go
func searchDocsStub(ctx context.Context, req *mcp.CallToolRequest, input SearchDocsInput) (*mcp.CallToolResult, SearchDocsOutput, error) {
    return nil, SearchDocsOutput{
        Results: []SearchResult{},
        Message: "Search not yet implemented",
    }, nil
}

func fetchDocStub(ctx context.Context, req *mcp.CallToolRequest, input FetchDocInput) (*mcp.CallToolResult, FetchDocOutput, error) {
    return nil, FetchDocOutput{
        Found: false,
    }, nil
}

func listDocsStub(ctx context.Context, req *mcp.CallToolRequest, input ListDocsInput) (*mcp.CallToolResult, ListDocsOutput, error) {
    return nil, ListDocsOutput{
        Paths: []string{},
        Count: 0,
    }, nil
}
```

3. Create `cmd/mcp-server/main.go`:

```go
package main

import (
    "context"
    "log"
    "os"
    "os/signal"
    "syscall"

    mcpserver "github.com/bull/eino-mcp-server/internal/mcp"
)

func main() {
    // Create context that cancels on SIGTERM/SIGINT
    ctx, cancel := signal.NotifyContext(context.Background(), syscall.SIGTERM, syscall.SIGINT)
    defer cancel()

    // Create server (dependencies will be wired in Plan 03)
    server := mcpserver.NewServer(&mcpserver.Config{})

    // Run server (blocks until client disconnects or signal received)
    if err := server.Run(ctx); err != nil {
        log.Printf("server error: %v", err)
        os.Exit(1)
    }
}
```
  </action>
  <verify>`go build ./cmd/mcp-server/...` produces binary; `./cmd/mcp-server/mcp-server &` and test with MCP Inspector or manual JSON-RPC</verify>
  <done>Server compiles, starts without error, registers 3 tools</done>
</task>

</tasks>

<verification>
1. `go build ./...` succeeds
2. `./cmd/mcp-server/mcp-server` starts and doesn't crash
3. Server responds to initialize handshake (test with MCP Inspector or echo '{"jsonrpc":"2.0","method":"initialize","params":{},"id":1}' | ./cmd/mcp-server/mcp-server)
</verification>

<success_criteria>
- MCP SDK added as dependency
- Server binary compiles and runs
- Three tools registered (search_docs, fetch_doc, list_docs)
- Stub handlers return valid (empty) responses
</success_criteria>

<output>
After completion, create `.planning/phases/03-mcp-server-core/03-01-SUMMARY.md`
</output>
