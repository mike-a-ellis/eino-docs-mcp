---
phase: 02-document-processing
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/markdown/chunker.go
autonomous: true

must_haves:
  truths:
    - "Chunker splits markdown at H1 and H2 header boundaries"
    - "Each chunk includes prepended header hierarchy for context"
    - "Chunks preserve complete section content without truncation"
  artifacts:
    - path: "internal/markdown/chunker.go"
      provides: "Header-based markdown chunking"
      exports: ["Chunker", "Chunk", "ChunkDocument"]
  key_links:
    - from: "internal/markdown/chunker.go"
      to: "yuin/goldmark"
      via: "AST parsing"
      pattern: "goldmark\\.New|parser\\.Parse"
    - from: "internal/markdown/chunker.go"
      to: "go.abhg.dev/goldmark/toc"
      via: "Header extraction"
      pattern: "toc\\.Inspect"
---

<objective>
Implement markdown chunker with header hierarchy extraction

Purpose: Split markdown documents at semantic boundaries (H1/H2 headers) while preserving context through header path prepending. This is critical for retrieval quality - research shows 40-60% improvement over naive chunking.

Output: Chunker that produces chunks with header context ready for embedding.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-document-processing/02-RESEARCH.md
@internal/storage/models.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement header-based markdown chunker</name>
  <files>internal/markdown/chunker.go</files>
  <action>
Create chunker using goldmark and go.abhg.dev/goldmark/toc:

1. Add dependencies:
   - go get github.com/yuin/goldmark
   - go get go.abhg.dev/goldmark/toc

2. Define Chunk struct:
   ```go
   type Chunk struct {
       Index      int      // Position in document (0, 1, 2...)
       HeaderPath string   // Hierarchy: "# Doc Title > ## Section Name"
       Content    string   // Chunk content WITH header path prepended
       RawContent string   // Original content without header prefix
   }
   ```

3. Define Chunker struct:
   - Stores goldmark parser instance
   - Configures with parser.WithAutoHeadingID() for TOC extraction

4. NewChunker function:
   - Creates goldmark parser with options
   - Returns configured Chunker

5. ChunkDocument method:
   - Parse markdown to AST using goldmark
   - Use toc.Inspect to extract header hierarchy:
     ```go
     tree, err := toc.Inspect(doc, src,
         toc.MinDepth(1),  // Include H1
         toc.MaxDepth(2),  // Split at H1 and H2 only
         toc.Compact(true),
     )
     ```
   - Walk AST to extract content between header boundaries
   - For each section:
     - Build header path (e.g., "# Installation > ## Prerequisites")
     - Extract content from header to next H1/H2 or EOF
     - Prepend header path to content
     - Create Chunk with index, paths, and content
   - Return []Chunk

6. Key implementation detail - AST content extraction:
   - Use node.Lines() to get source line positions
   - Track current header and its level
   - When encountering H1/H2, finalize previous chunk and start new one
   - Include all content under header until next H1/H2

7. Header path formatting:
   - Format: "# Parent > ## Child" (shows hierarchy)
   - Helps embedding capture context even if chunk content is brief

Decision (from CONTEXT.md): No overlap between chunks. Header hierarchy provides sufficient context.
Decision (from CONTEXT.md): No size limits - keep sections at natural size.
  </action>
  <verify>
go build ./internal/markdown/...
  </verify>
  <done>
Chunker splits markdown at H1/H2 boundaries with header path prepending; compiles without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for chunker</name>
  <files>internal/markdown/chunker_test.go</files>
  <action>
Create comprehensive unit tests for the chunker:

1. TestChunkDocument_BasicHeaders:
   - Input: Markdown with H1 and multiple H2s
   - Verify: Correct number of chunks, header paths match hierarchy

2. TestChunkDocument_NestedContent:
   - Input: Markdown with content including code blocks, lists, nested elements
   - Verify: Content preserved completely, no truncation

3. TestChunkDocument_HeaderHierarchy:
   - Input: H1 "Installation" > H2 "Prerequisites" > H2 "Steps"
   - Verify: Header paths are "# Installation", "# Installation > ## Prerequisites", etc.

4. TestChunkDocument_SingleSection:
   - Input: Markdown with only content (no headers)
   - Verify: Returns single chunk with empty header path

5. TestChunkDocument_PrependedContent:
   - Verify: Chunk.Content starts with header path followed by actual content

Sample test input:
```markdown
# Getting Started

Introduction text.

## Installation

Install steps here.

## Configuration

Config details here.
```

Expected chunks:
1. HeaderPath: "# Getting Started", Content includes intro text
2. HeaderPath: "# Getting Started > ## Installation", Content includes install steps
3. HeaderPath: "# Getting Started > ## Configuration", Content includes config details
  </action>
  <verify>
go test -v ./internal/markdown/...
  </verify>
  <done>
All chunker tests pass, validating header splitting and hierarchy preservation
  </done>
</task>

</tasks>

<verification>
After both tasks complete:
1. `go build ./...` succeeds
2. `go test ./internal/markdown/...` passes
3. Chunker correctly splits sample markdown at header boundaries
4. Header paths correctly show hierarchy
</verification>

<success_criteria>
- Chunker splits at H1 and H2 boundaries (not H3+)
- Each chunk has header path prepended to content
- Content is preserved completely (no truncation)
- Unit tests verify all chunking behaviors
</success_criteria>

<output>
After completion, create `.planning/phases/02-document-processing/02-02-SUMMARY.md`
</output>
