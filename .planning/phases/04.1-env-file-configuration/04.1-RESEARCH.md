# Phase 4.1: Environment Configuration - Research

**Researched:** 2026-01-25
**Domain:** Go environment configuration with .env files
**Confidence:** HIGH

## Summary

Environment configuration in Go applications follows the twelve-factor app methodology: use environment variables in production, but .env files for local development convenience. The standard approach uses `github.com/joho/godotenv` (feature-complete, 226k+ dependents) to load .env files early in the application lifecycle, combined with `os.Getenv()` for reading values. For type-safe configuration, `github.com/caarlos0/env` (v11, feature-complete) parses environment variables into structs with validation support.

The codebase already uses `os.Getenv()` in both binaries (cmd/mcp-server/main.go, cmd/sync/main.go) for QDRANT_HOST, QDRANT_PORT, OPENAI_API_KEY, and GITHUB_TOKEN. Adding .env file support requires minimal changes: install godotenv, call `godotenv.Load()` early in main(), handle missing files gracefully (production won't have .env files), and create .env.example as a template.

For this project's deployment model (local development + Fly.io production), the pattern is: local.env for development with all required variables, prod.env documentation showing which variables are set via `fly secrets`, and never commit actual .env files to Git. Production environments on Fly.io inject secrets as standard environment variables at runtime, bypassing .env file loading entirely.

**Primary recommendation:** Use godotenv with graceful fallback (ignore missing .env in production), maintain separate .env.example template, and document which environment (local vs Fly.io) requires which configuration method.

## Standard Stack

The established libraries/tools for Go environment configuration:

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| joho/godotenv | v1.5.1 | Load .env files into os.Environ() | De facto standard Go port of Ruby's dotenv; 226k+ dependent repos; feature-complete and stable since 2015; zero breaking changes policy |
| stdlib os | builtin | Read environment variables via os.Getenv() | Built-in Go standard library; universal; no dependencies; already used throughout the codebase |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| caarlos0/env | v11.3.1 | Parse environment variables into typed structs with validation | Type-safe config with required field validation and default values; reduces boilerplate os.Getenv() calls |
| spf13/viper | latest | Multi-format config file support (YAML/JSON/ENV) with hot-reload | Complex applications needing remote config sources, multiple file formats, or config watching; overkill for simple .env needs |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| godotenv | Viper with AutomaticEnv() | Viper adds complexity (6+ dependencies, 15k+ LOC) for features this project doesn't need (YAML/JSON, remote config, hot-reload); godotenv is 600 LOC, zero deps |
| godotenv | Manual parsing | Reinventing .env file parser risks bugs with quoted values, comments, variable expansion; godotenv handles edge cases correctly |
| os.Getenv() | caarlos0/env struct parsing | Struct-based parsing adds type safety and validation but requires defining config structs; worth it for 5+ variables with validation needs |

**Installation:**
```bash
go get github.com/joho/godotenv
# Optional: for type-safe struct parsing
go get github.com/caarlos0/env/v11
```

## Architecture Patterns

### Recommended Project Structure
```
/
├── cmd/
│   ├── mcp-server/
│   │   └── main.go          # Load .env early, before component init
│   └── sync/
│       └── main.go          # Load .env early, before component init
├── .env                     # Actual secrets (NEVER commit - git ignored)
├── .env.example             # Template with variable names (committed)
├── local.env                # Local development config (git ignored)
├── prod.env                 # Production variable documentation (committed, no actual secrets)
└── .gitignore              # Must include .env and local.env
```

### Pattern 1: Load Early, Fail Gracefully
**What:** Load .env file in main() before initializing any components that read environment variables, but don't fail if file is missing (production won't have it).
**When to use:** Applications deployed to production platforms (Fly.io, AWS, Docker) that inject environment variables at runtime.
**Example:**
```go
// Source: https://github.com/joho/godotenv
package main

import (
    "log"
    "os"
    "github.com/joho/godotenv"
)

func main() {
    // Load .env file if it exists (development), ignore if missing (production)
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found, using environment variables")
    }

    // Now initialize components that read from environment
    apiKey := os.Getenv("OPENAI_API_KEY")
    // ...
}
```

### Pattern 2: Environment-Specific .env Files
**What:** Load different .env files based on environment detection, following precedence order.
**When to use:** Applications with distinct local/staging/production configurations needing different default values.
**Example:**
```go
// Source: https://github.com/joho/godotenv
env := os.Getenv("APP_ENV")
if env == "" {
    env = "development"
}

// Load in precedence order (later files don't override earlier ones)
godotenv.Load(".env." + env + ".local")  // .env.development.local
if env != "test" {
    godotenv.Load(".env.local")           // .env.local (personal overrides)
}
godotenv.Load(".env." + env)              // .env.development
godotenv.Load()                            // .env (defaults)
```

### Pattern 3: Fail-Fast Validation
**What:** Validate required environment variables immediately after loading, before initializing components.
**When to use:** Always - prevents runtime failures deep in the application when required config is missing.
**Example:**
```go
// Source: https://medium.com/@zulfiqarjunejo/fail-early-succeed-strong-mastering-environment-variable-validation-9e26f3a4e14f
func validateRequiredEnvVars() error {
    required := []string{"OPENAI_API_KEY", "QDRANT_HOST", "GITHUB_TOKEN"}
    var missing []string

    for _, key := range required {
        if os.Getenv(key) == "" {
            missing = append(missing, key)
        }
    }

    if len(missing) > 0 {
        return fmt.Errorf("missing required environment variables: %v", missing)
    }
    return nil
}

func main() {
    godotenv.Load() // Load .env if available

    if err := validateRequiredEnvVars(); err != nil {
        log.Fatalf("Configuration error: %v", err)
    }
    // Continue initialization...
}
```

### Pattern 4: Type-Safe Struct-Based Config
**What:** Define a config struct with env tags, parse once, use throughout the application with type safety.
**When to use:** Applications with 5+ environment variables needing validation, defaults, and type conversion.
**Example:**
```go
// Source: https://github.com/caarlos0/env
type Config struct {
    QdrantHost    string `env:"QDRANT_HOST" envDefault:"localhost"`
    QdrantPort    int    `env:"QDRANT_PORT" envDefault:"6334"`
    OpenAIAPIKey  string `env:"OPENAI_API_KEY,required"`
    GitHubToken   string `env:"GITHUB_TOKEN"`
}

func main() {
    godotenv.Load() // Load .env if available

    cfg, err := env.ParseAs[Config]()
    if err != nil {
        log.Fatalf("Failed to parse configuration: %v", err)
    }

    // Type-safe config access
    store, _ := storage.NewQdrantStorage(cfg.QdrantHost, cfg.QdrantPort)
}
```

### Anti-Patterns to Avoid
- **Loading .env files deep in the codebase**: Load once in main(), not in library init() functions - makes testing harder and creates hidden dependencies
- **Using Overload() by default**: `godotenv.Overload()` overwrites existing environment variables, breaking production deployments that inject secrets; use `Load()` which respects existing vars
- **Committing .env files to Git**: Secrets leak into repository history forever; always .gitignore .env files, commit .env.example templates instead
- **Failing startup when .env is missing**: Production environments (Docker, Fly.io, Kubernetes) inject environment variables directly; code should gracefully handle missing .env files
- **No .env.example template**: New developers don't know which variables are required; maintain .env.example with all variable names and placeholder values

## Don't Hand-Roll

Problems that look simple but have existing solutions:

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| .env file parsing | Custom parser with strings.Split() | godotenv.Load() | Edge cases: quoted values with spaces, inline comments, variable expansion, escape sequences, multiline values - godotenv handles all correctly |
| Type conversion from strings | Manual fmt.Sscanf() for each variable | caarlos0/env struct parsing | Handles slices, maps, durations, URLs, custom types via TextUnmarshaler; validates required fields; provides defaults |
| Environment detection | Custom if/else chains checking ENV vars | godotenv's multi-file loading pattern | Established convention (.env.{env}.local, .env.local, .env.{env}, .env) prevents precedence bugs |
| Configuration validation | Ad-hoc nil checks scattered through code | Centralized validation function at startup | Fail-fast principle: detect missing config before initializing expensive resources (DB connections, API clients) |

**Key insight:** .env file format appears simple (KEY=VALUE) but has subtle complexity (quoting, escaping, comments, expansion) that godotenv solves correctly. Custom parsers break on edge cases like `DATABASE_URL="postgres://user:p@ss=word@host/db"` (quotes with special chars).

## Common Pitfalls

### Pitfall 1: Wrong godotenv Call Timing
**What goes wrong:** Calling godotenv.Load() after components have already read from os.Getenv() results in components using default/empty values instead of .env file values.
**Why it happens:** Components initialize in init() functions or package-level variables before main() runs.
**How to avoid:** Call godotenv.Load() as the absolute first line in main(), before any component initialization. Don't use package init() for godotenv.Load() as init() order across packages is undefined.
**Warning signs:** .env file exists with correct values but application behaves as if environment variables are unset.

### Pitfall 2: Production Deployment with .env Files
**What goes wrong:** Deploying .env files to production containers/servers creates security risks (secrets in filesystem, version control issues) and violates twelve-factor app methodology.
**Why it happens:** Developers assume .env files are the "right way" for all environments because they work locally.
**How to avoid:** .env files are development-only convenience. Production platforms (Fly.io, AWS ECS, Kubernetes) inject environment variables through platform-specific secret management. Document which variables are set where (local.env for dev, fly secrets for prod).
**Warning signs:** Production deployment instructions include "copy .env file to server" or Dockerfile has `COPY .env .env`.

### Pitfall 3: Testing with Missing .env Files
**What goes wrong:** Tests run in temporary directories or CI environments fail when godotenv.Load() can't find .env files, or tests pass locally but fail in CI.
**Why it happens:** Tests run from different working directories (go test changes to package directory), CI environments don't have .env files.
**How to avoid:** Use godotenv.Load() gracefully (ignore errors), OR use explicit file paths relative to test files, OR set environment variables in test setup functions, OR use t.Setenv() in Go 1.17+ for test-scoped env vars.
**Warning signs:** Tests fail with "no such file or directory" for .env file, or tests pass locally but fail in CI/CD pipelines.

### Pitfall 4: Mixing Load() and Overload()
**What goes wrong:** Using godotenv.Overload() overwrites production environment variables injected by the platform, causing production to use development values from accidentally-deployed .env files.
**Why it happens:** Developers misunderstand the precedence rules - Load() respects existing env vars, Overload() clobbers them.
**How to avoid:** Always use Load(), never Overload() unless you have a specific reason to override existing variables. Production platforms set real secrets; .env files are fallbacks for development.
**Warning signs:** Production application connects to development database/services despite correct production environment variables being set in platform.

### Pitfall 5: No .gitignore for .env Files
**What goes wrong:** Actual .env files with real secrets get committed to Git, leaking API keys, database credentials, and tokens into repository history permanently.
**Why it happens:** Developer forgets to add .env to .gitignore before first commit, or .gitignore has wrong pattern (.env.* instead of .env).
**How to avoid:** Add .env and local.env to .gitignore BEFORE creating .env files. Commit .env.example template first. Use git-secrets or pre-commit hooks to scan for accidental commits.
**Warning signs:** GitHub secret scanning alerts, API keys showing up in commit history, production credentials visible in repository.

### Pitfall 6: No Environment Variable Validation
**What goes wrong:** Application starts successfully but fails later with cryptic errors (nil pointer, API 401 errors, connection refused) because required environment variables are missing or invalid.
**Why it happens:** Code reads environment variables throughout the application with no centralized validation; empty string returns from os.Getenv() go unchecked.
**How to avoid:** Validate all required environment variables immediately after godotenv.Load() in main(), before initializing components. Use caarlos0/env with `required` tags or write explicit validation function. Fail fast with clear error messages listing missing variables.
**Warning signs:** Application crashes 30 seconds after startup with "API key not set" error from deep in a goroutine, or silent failures due to empty string values.

## Code Examples

Verified patterns from official sources:

### Loading .env File in main() (Simple)
```go
// Source: https://github.com/joho/godotenv
package main

import (
    "log"
    "os"
    "github.com/joho/godotenv"
)

func main() {
    // Load .env file - ignore error if file doesn't exist (production)
    if err := godotenv.Load(); err != nil {
        log.Println("No .env file found")
    }

    // Read environment variables
    qdrantHost := getEnv("QDRANT_HOST", "localhost")
    apiKey := os.Getenv("OPENAI_API_KEY")

    // Continue initialization...
}

func getEnv(key, defaultValue string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return defaultValue
}
```

### Environment-Specific .env Files
```go
// Source: https://github.com/joho/godotenv
package main

import (
    "log"
    "os"
    "github.com/joho/godotenv"
)

func main() {
    // Load environment-specific .env files in precedence order
    env := getEnv("APP_ENV", "development")

    // Files loaded later do NOT override earlier files (existing vars take precedence)
    godotenv.Load(".env." + env + ".local")  // Highest precedence
    if env != "test" {
        godotenv.Load(".env.local")
    }
    godotenv.Load(".env." + env)
    godotenv.Load()  // Lowest precedence (base defaults)

    log.Printf("Running in %s environment", env)
    // Continue initialization...
}

func getEnv(key, defaultValue string) string {
    if v := os.Getenv(key); v != "" {
        return v
    }
    return defaultValue
}
```

### Type-Safe Config with Validation
```go
// Source: https://github.com/caarlos0/env
package main

import (
    "log"
    "github.com/caarlos0/env/v11"
    "github.com/joho/godotenv"
)

type Config struct {
    QdrantHost    string `env:"QDRANT_HOST" envDefault:"localhost"`
    QdrantPort    int    `env:"QDRANT_PORT" envDefault:"6334"`
    OpenAIAPIKey  string `env:"OPENAI_API_KEY,required,notEmpty"`
    GitHubToken   string `env:"GITHUB_TOKEN"` // Optional
}

func main() {
    // Load .env file if available
    godotenv.Load()

    // Parse and validate configuration
    cfg, err := env.ParseAs[Config]()
    if err != nil {
        log.Fatalf("Configuration error: %v", err)
    }

    // Use type-safe config
    log.Printf("Connecting to Qdrant at %s:%d", cfg.QdrantHost, cfg.QdrantPort)
    // Initialize components with cfg...
}
```

### Explicit Validation Function
```go
// Source: https://medium.com/@zulfiqarjunejo/fail-early-succeed-strong-mastering-environment-variable-validation-9e26f3a4e14f
package main

import (
    "fmt"
    "log"
    "os"
    "strings"
    "github.com/joho/godotenv"
)

func validateConfig() error {
    required := map[string]string{
        "OPENAI_API_KEY": "OpenAI API key for embeddings",
        "QDRANT_HOST":    "Qdrant vector database host",
    }

    var missing []string
    for key, description := range required {
        if os.Getenv(key) == "" {
            missing = append(missing, fmt.Sprintf("%s (%s)", key, description))
        }
    }

    if len(missing) > 0 {
        return fmt.Errorf("missing required environment variables:\n  %s",
            strings.Join(missing, "\n  "))
    }
    return nil
}

func main() {
    godotenv.Load()

    if err := validateConfig(); err != nil {
        log.Fatalf("Configuration error: %v\n\nSet these in .env file or environment", err)
    }

    // Safe to proceed - all required vars are set
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Config files (YAML/JSON) with sensitive data | .env files (dev) + platform secrets (prod) | ~2014 (twelve-factor app) | Secrets no longer committed to repos; environment-specific config separated |
| Viper for all projects | godotenv for simple cases, Viper only when needed | ~2020 | Reduced dependencies for projects with simple config needs; Viper still dominant for complex apps |
| Manual os.Getenv() calls | Struct-based parsing with caarlos0/env | ~2018 | Type safety, validation, defaults in one place; less boilerplate |
| Hard-coded defaults in code | envDefault tags or fallback values | Ongoing | Configuration visible, changeable without recompilation |

**Deprecated/outdated:**
- **godotenv autoload package** (`import _ "github.com/joho/godotenv/autoload"`): Implicit loading hides configuration dependencies; explicit godotenv.Load() in main() is now preferred for clarity
- **Env-specific config files in repo** (config.dev.json, config.prod.json): Replaced by single .env.example template + platform-injected environment variables; avoids committing production config to repos

## Open Questions

Things that couldn't be fully resolved:

1. **Should GITHUB_TOKEN be required or optional?**
   - What we know: GitHub API allows unauthenticated requests (60 req/hour rate limit); authenticated requests get 5000 req/hour. Current code treats GITHUB_TOKEN as optional.
   - What's unclear: Whether sync CLI usage patterns will hit the 60 req/hour limit (depends on repo size, sync frequency). Codebase fetches from cloudwego/cloudwego.github.io which may have 100+ docs.
   - Recommendation: Keep GITHUB_TOKEN optional but document the rate limit trade-off in .env.example. If users hit rate limits, they'll know to add the token.

2. **Should we use separate local.env and prod.env files or .env.development and .env.production?**
   - What we know: Standard twelve-factor pattern uses .env.{environment} naming; project requirements specify local.env and prod.env naming.
   - What's unclear: Whether "prod.env" will contain actual secrets (bad) or just documentation (good).
   - Recommendation: Use local.env for actual local secrets (git-ignored), use prod.env as documentation-only file (committed) showing which variables exist and explaining they're set via `fly secrets set` in production. Add comment header to prod.env: "# This file is documentation only - production secrets are managed via fly secrets set".

3. **Should we add caarlos0/env for type-safe config parsing?**
   - What we know: Codebase currently uses simple getEnv() and getEnvInt() helpers; works fine. caarlos0/env adds validation, type safety, and defaults but increases complexity.
   - What's unclear: Whether the project will grow to need more sophisticated config handling (5+ variables with complex validation).
   - Recommendation: Start with godotenv + existing getEnv helpers (minimal change). Consider caarlos0/env later if: (a) validation needs become complex, (b) more environment variables are added (>8), or (c) type conversion errors become a pain point. YAGNI principle - don't add it until needed.

## Sources

### Primary (HIGH confidence)
- [godotenv GitHub Repository](https://github.com/joho/godotenv) - Official documentation, installation, API reference
- [godotenv Go Package Documentation](https://pkg.go.dev/github.com/joho/godotenv) - API signatures, function documentation
- [caarlos0/env GitHub Repository](https://github.com/caarlos0/env) - Struct-based env parsing, validation patterns
- [Twelve-Factor App: Config](https://12factor.net/config) - Official twelve-factor methodology for environment configuration
- [Fly.io Secrets Documentation](https://fly.io/docs/apps/secrets/) - How to manage secrets on Fly.io platform

### Secondary (MEDIUM confidence)
- [Difference between Godotenv and Viper in Golang - DEV Community](https://dev.to/jutionck/difference-between-godotenv-vs-viper-in-golang-4hbk) - Library comparison, use cases
- [Fail Early, Succeed Strong: Mastering Environment Variable Validation - Medium](https://medium.com/@zulfiqarjunejo/fail-early-succeed-strong-mastering-environment-variable-validation-9e26f3a4e14f) - Validation patterns and best practices
- [Load config from file & environment variables in Golang with Viper - DEV Community](https://dev.to/techschoolguru/load-config-from-file-environment-variables-in-golang-with-viper-2j2d) - Viper as alternative approach
- [Best Practices for Environment Variables Secrets Management - GitGuardian](https://blog.gitguardian.com/secure-your-secrets-with-env/) - Security best practices for .env files

### Tertiary (LOW confidence)
- [Loading environment variables properly in Go - TheDeveloperCafe](https://thedevelopercafe.com/articles/loading-environment-variables-properly-in-go-with-env-and-godotenv-7ec94d4101a7) - Community tutorial on godotenv + caarlos0/env integration
- [Use Environment Variable in your next Golang Project - Towards Data Science](https://towardsdatascience.com/use-environment-variable-in-your-next-golang-project-39e17c3aaa66/) - General patterns and community practices

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - godotenv is de facto standard (226k+ dependents, feature-complete), verified through official docs and pkg.go.dev
- Architecture: HIGH - Patterns verified from official godotenv and caarlos0/env documentation, twelve-factor app methodology (authoritative source)
- Pitfalls: MEDIUM - Based on community articles (DEV Community, Medium) and issue discussions, cross-referenced with official docs where possible

**Research date:** 2026-01-25
**Valid until:** 2026-04-25 (90 days - mature, stable libraries with no-breaking-changes policy)
