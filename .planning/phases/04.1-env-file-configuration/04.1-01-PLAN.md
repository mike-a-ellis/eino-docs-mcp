---
phase: 04.1-env-file-configuration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - go.mod
  - go.sum
  - cmd/mcp-server/main.go
  - cmd/sync/main.go
  - .env.example
  - local.env
  - prod.env
  - .gitignore
autonomous: true

must_haves:
  truths:
    - "Both mcp-server and sync CLI load environment variables from .env files automatically"
    - "local.env file exists for local development configuration"
    - "prod.env file documents production environment variables for Fly.io"
    - ".env and local.env are git-ignored to prevent secret leakage"
    - "Missing .env file does not prevent application startup (graceful fallback)"
  artifacts:
    - path: "cmd/mcp-server/main.go"
      provides: "godotenv.Load() call at start of main()"
      contains: "godotenv.Load"
    - path: "cmd/sync/main.go"
      provides: "godotenv.Load() call at start of main()"
      contains: "godotenv.Load"
    - path: ".env.example"
      provides: "Template with all environment variable names"
      contains: "OPENAI_API_KEY"
    - path: "local.env"
      provides: "Local development configuration template"
      contains: "QDRANT_HOST"
    - path: "prod.env"
      provides: "Production configuration documentation"
      contains: "fly secrets"
    - path: ".gitignore"
      provides: "Git ignore rules for sensitive files"
      contains: ".env"
  key_links:
    - from: "cmd/mcp-server/main.go"
      to: "github.com/joho/godotenv"
      via: "import and Load() call"
      pattern: "godotenv\\.Load"
    - from: "cmd/sync/main.go"
      to: "github.com/joho/godotenv"
      via: "import and Load() call"
      pattern: "godotenv\\.Load"
---

<objective>
Add .env file support to both mcp-server and sync CLI binaries using godotenv library.

Purpose: Enable local development configuration via .env files while maintaining compatibility with Fly.io production deployment that injects environment variables directly.

Output: Both binaries load configuration from .env files automatically, with local.env for development and prod.env documenting production setup.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-env-file-configuration/04.1-RESEARCH.md

# Current implementation to modify
@cmd/mcp-server/main.go
@cmd/sync/main.go
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add godotenv and update both main.go files</name>
  <files>
    go.mod
    go.sum
    cmd/mcp-server/main.go
    cmd/sync/main.go
  </files>
  <action>
1. Add godotenv dependency:
   ```bash
   go get github.com/joho/godotenv
   ```

2. Update cmd/mcp-server/main.go:
   - Add import for "github.com/joho/godotenv"
   - Add godotenv.Load() call as FIRST line in main() function, before signal.NotifyContext
   - Use graceful fallback pattern (log message if no .env file found, don't fail):
     ```go
     // Load .env file if present (local development), ignore if missing (production)
     if err := godotenv.Load(); err != nil {
         log.Println("No .env file found, using environment variables")
     }
     ```

3. Update cmd/sync/main.go:
   - Add import for "github.com/joho/godotenv"
   - Add godotenv.Load() call as FIRST line in main() function, before rootCmd.Execute():
     ```go
     // Load .env file if present (local development), ignore if missing (production)
     if err := godotenv.Load(); err != nil {
         // Silently continue - production environments inject env vars directly
     }
     ```
   - Note: sync CLI is quieter, no log message for missing .env

4. Run `go mod tidy` to update go.sum
  </action>
  <verify>
    - `grep godotenv go.mod` shows the dependency
    - `grep -n "godotenv.Load" cmd/mcp-server/main.go` shows the call in main()
    - `grep -n "godotenv.Load" cmd/sync/main.go` shows the call in main()
    - `go build ./...` succeeds
  </verify>
  <done>
    Both binaries import godotenv and call Load() at the start of main() with graceful fallback for missing files.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create environment files and .gitignore</name>
  <files>
    .env.example
    local.env
    prod.env
    .gitignore
  </files>
  <action>
1. Update .env.example with ALL required and optional environment variables:
   ```
   # EINO MCP Server Configuration
   # Copy this file to .env or local.env and fill in your values

   # Qdrant Vector Database
   QDRANT_HOST=localhost
   QDRANT_PORT=6334

   # OpenAI API (REQUIRED for embeddings and metadata generation)
   OPENAI_API_KEY=sk-your-api-key-here

   # GitHub API (optional but recommended for higher rate limits)
   # Without token: 60 requests/hour
   # With token: 5000 requests/hour
   GITHUB_TOKEN=ghp_your-github-token-here
   ```

2. Create local.env for local development (same content as .env.example but with clear header):
   ```
   # Local Development Configuration
   # This file is git-ignored. Copy from .env.example and add your secrets.

   # Qdrant Vector Database (Docker default)
   QDRANT_HOST=localhost
   QDRANT_PORT=6334

   # OpenAI API (REQUIRED)
   OPENAI_API_KEY=

   # GitHub API (optional)
   GITHUB_TOKEN=
   ```

3. Create prod.env as DOCUMENTATION ONLY (committed to repo, no actual secrets):
   ```
   # Production Configuration (Fly.io)
   # ================================================
   # This file is DOCUMENTATION ONLY - no secrets here!
   # Production secrets are managed via: fly secrets set
   #
   # To set production secrets:
   #   fly secrets set OPENAI_API_KEY=sk-...
   #   fly secrets set GITHUB_TOKEN=ghp_...
   #
   # Qdrant runs as internal service, uses default localhost:6334
   # ================================================

   # These variables are set automatically by Fly.io or via fly secrets:
   # QDRANT_HOST=localhost (internal service)
   # QDRANT_PORT=6334 (default gRPC port)
   # OPENAI_API_KEY=<set via fly secrets set>
   # GITHUB_TOKEN=<set via fly secrets set>
   ```

4. Create .gitignore with proper patterns:
   ```
   # Environment files with secrets
   .env
   local.env
   *.local.env

   # Keep these committed
   !.env.example
   !prod.env

   # Go build artifacts
   /bin/
   *.exe
   *.dll
   *.so
   *.dylib

   # Test artifacts
   *.test
   *.out
   coverage.txt

   # IDE
   .idea/
   .vscode/
   *.swp
   *.swo

   # OS
   .DS_Store
   Thumbs.db

   # Qdrant data (if running locally outside Docker)
   qdrant_data/
   ```

5. If .env file exists with actual secrets, rename it to local.env (user's secrets preserved)
  </action>
  <verify>
    - `.env.example` contains OPENAI_API_KEY placeholder
    - `local.env` exists with empty values for secrets
    - `prod.env` exists with documentation header mentioning "fly secrets set"
    - `.gitignore` contains `.env` and `local.env` patterns
    - `git status` shows .env.example and prod.env as tracked, .env and local.env as ignored
  </verify>
  <done>
    All environment files exist with appropriate content. .env and local.env are git-ignored, .env.example and prod.env are committed.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration and cleanup</name>
  <files>
    (no new files - verification only)
  </files>
  <action>
1. Test that .env file loading works:
   - Create a test .env file with QDRANT_HOST=testhost
   - Run: `go run cmd/mcp-server/main.go` (will fail to connect to Qdrant, but should log about .env)
   - Verify log shows connection attempt to testhost (proves .env was loaded)

2. Test that missing .env works (graceful fallback):
   - Rename .env temporarily
   - Run: `go run cmd/sync/main.go --help` (help doesn't need Qdrant)
   - Should succeed without error about missing .env

3. Run all existing tests to ensure nothing broke:
   ```bash
   go test ./...
   ```

4. Verify git status is clean for sensitive files:
   ```bash
   git status --porcelain | grep -E "\.env$|local\.env$" || echo "No secret files staged"
   ```
  </action>
  <verify>
    - `go test ./...` passes
    - `go build ./cmd/mcp-server && go build ./cmd/sync` both succeed
    - Manually verify mcp-server startup log mentions .env loading behavior
  </verify>
  <done>
    Both binaries correctly load .env files when present and gracefully handle missing files. All tests pass and no secrets are tracked in git.
  </done>
</task>

</tasks>

<verification>
After completing all tasks:

1. **Dependency verification:**
   - `grep "github.com/joho/godotenv" go.mod` returns a match

2. **Code integration verification:**
   - `grep -l "godotenv.Load" cmd/*/main.go | wc -l` returns 2 (both binaries)

3. **File existence verification:**
   - All required files exist: .env.example, local.env, prod.env, .gitignore

4. **Git safety verification:**
   - `git check-ignore .env` returns 0 (file is ignored)
   - `git check-ignore local.env` returns 0 (file is ignored)
   - `git check-ignore .env.example` returns non-zero (file is tracked)
   - `git check-ignore prod.env` returns non-zero (file is tracked)

5. **Build verification:**
   - `go build ./...` succeeds without errors
   - `go test ./...` passes
</verification>

<success_criteria>
- godotenv v1.5.1 added to go.mod
- Both cmd/mcp-server/main.go and cmd/sync/main.go call godotenv.Load() at start of main()
- .env.example updated with all required variables (QDRANT_HOST, QDRANT_PORT, OPENAI_API_KEY, GITHUB_TOKEN)
- local.env created for local development (git-ignored)
- prod.env created as documentation-only file explaining Fly.io secrets setup
- .gitignore protects .env and local.env from accidental commits
- go build ./... and go test ./... pass
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-env-file-configuration/04.1-01-SUMMARY.md`
</output>
