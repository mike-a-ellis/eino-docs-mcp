---
phase: 05-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - Dockerfile
autonomous: true

must_haves:
  truths:
    - "Docker build produces a minimal runtime image with the mcp-server binary"
    - "Built image is under 50MB (multi-stage build eliminates build dependencies)"
    - "Binary runs as non-root user in container"
  artifacts:
    - path: "Dockerfile"
      provides: "Multi-stage build definition for Go MCP server"
      contains: "FROM golang:1.24 AS builder"
  key_links:
    - from: "Dockerfile"
      to: "cmd/mcp-server/main.go"
      via: "go build command"
      pattern: "go build.*cmd/mcp-server"
---

<objective>
Create multi-stage Dockerfile for efficient Go application containerization.

Purpose: Production deployment requires minimal, secure container images. Multi-stage builds compile the Go binary with full toolchain then copy only the binary to a minimal runtime image, reducing image size from 1GB+ to ~25MB.

Output: Dockerfile that builds mcp-server binary and produces distroless runtime image.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deployment/05-RESEARCH.md
@cmd/mcp-server/main.go
@go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile</name>
  <files>Dockerfile</files>
  <action>
Create Dockerfile with two stages:

**Build stage (golang:1.24):**
- WORKDIR /build
- Copy go.mod and go.sum first (layer caching)
- RUN go mod download
- Copy all source code
- Build with: CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -ldflags="-w -s" -o mcp-server ./cmd/mcp-server
- The -w -s flags strip debug info for smaller binary

**Runtime stage (gcr.io/distroless/static-debian11):**
- Copy binary from builder stage to /app/mcp-server
- EXPOSE 8080 (documentation only)
- USER nonroot:nonroot (distroless has this user built-in)
- ENTRYPOINT ["/app/mcp-server"]

Reference the exact pattern from 05-RESEARCH.md "Dockerfile for Go MCP Server" section.
  </action>
  <verify>
Run: docker build -t eino-mcp-server:test .
- Build completes without errors
- Check image size: docker images eino-mcp-server:test (should be under 50MB)
  </verify>
  <done>Dockerfile exists and builds a minimal container image with the mcp-server binary</done>
</task>

</tasks>

<verification>
1. Dockerfile exists at project root
2. `docker build -t eino-mcp-server:test .` completes successfully
3. Image size is under 50MB: `docker images eino-mcp-server:test --format "{{.Size}}"`
4. Binary runs in container: `docker run --rm eino-mcp-server:test --help` (will fail without Qdrant, but shows binary starts)
</verification>

<success_criteria>
- Multi-stage Dockerfile exists with golang:1.24 builder and distroless runtime
- Docker build produces working image under 50MB
- Image runs as non-root user
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment/05-01-SUMMARY.md`
</output>
