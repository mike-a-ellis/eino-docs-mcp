---
phase: 05-deployment
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - cmd/mcp-server/main.go
  - internal/mcp/health.go
autonomous: true

must_haves:
  truths:
    - "GET /health returns JSON with server and Qdrant connectivity status"
    - "Health check returns 200 when Qdrant is connected, 503 when disconnected"
    - "Response includes timestamp for monitoring freshness"
  artifacts:
    - path: "internal/mcp/health.go"
      provides: "Health check HTTP handler"
      exports: ["NewHealthHandler", "HealthResponse"]
    - path: "cmd/mcp-server/main.go"
      provides: "HTTP server serving health endpoint alongside MCP"
      contains: "http.ListenAndServe"
  key_links:
    - from: "internal/mcp/health.go"
      to: "internal/storage/qdrant.go"
      via: "store.Health() call"
      pattern: "store\\.Health\\(ctx\\)"
---

<objective>
Implement HTTP health check endpoint for Fly.io deployment monitoring.

Purpose: Fly.io health checks determine routing decisions and catch deployment failures. A health endpoint that verifies both server availability AND Qdrant connectivity ensures deployments fail fast if dependencies are broken.

Output: /health endpoint returning JSON status, integrated into mcp-server startup.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deployment/05-RESEARCH.md
@.planning/phases/05-deployment/05-CONTEXT.md
@cmd/mcp-server/main.go
@internal/storage/qdrant.go
@internal/mcp/server.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check handler</name>
  <files>internal/mcp/health.go</files>
  <action>
Create internal/mcp/health.go with:

1. HealthResponse struct:
```go
type HealthResponse struct {
    Status    string `json:"status"`
    Qdrant    string `json:"qdrant"`
    Timestamp string `json:"timestamp"`
}
```

2. HealthChecker interface (minimal interface for storage dependency):
```go
type HealthChecker interface {
    Health(ctx context.Context) error
}
```

3. NewHealthHandler function:
- Takes HealthChecker (the storage layer implements this via Health() method)
- Returns http.HandlerFunc
- Creates context with 3-second timeout
- Calls store.Health(ctx)
- Returns JSON response:
  - If healthy: {"status":"healthy","qdrant":"connected","timestamp":"..."} with 200
  - If unhealthy: {"status":"unhealthy","qdrant":"disconnected","timestamp":"..."} with 503
- Timestamp in RFC3339 format

Reference the exact pattern from 05-RESEARCH.md "Health Check Endpoint Implementation" section.
  </action>
  <verify>
Run: go build ./internal/mcp/...
- No compilation errors
  </verify>
  <done>Health handler created with HealthChecker interface and JSON response</done>
</task>

<task type="auto">
  <name>Task 2: Integrate health endpoint into mcp-server</name>
  <files>cmd/mcp-server/main.go</files>
  <action>
Modify cmd/mcp-server/main.go to serve HTTP health endpoint:

1. Add imports: "net/http"

2. Get PORT from environment (default 8080):
```go
port := getEnv("PORT", "8080")
```

3. Create HTTP server with health handler before MCP server starts:
```go
// Start health check server in background
healthHandler := mcpserver.NewHealthHandler(store)
http.HandleFunc("/health", healthHandler)
go func() {
    addr := "0.0.0.0:" + port
    log.Printf("Starting health server on %s", addr)
    if err := http.ListenAndServe(addr, nil); err != nil {
        log.Printf("Health server error: %v", err)
    }
}()
```

4. The MCP server continues to run on stdio (unchanged).

Key: Bind to 0.0.0.0, NOT localhost/127.0.0.1 (Fly.io requirement per RESEARCH.md pitfall #1).
  </action>
  <verify>
1. Build: go build -o mcp-server ./cmd/mcp-server
2. Start Qdrant: docker-compose up -d
3. Run server with PORT set: PORT=8080 ./mcp-server &
4. Test health endpoint: curl -s http://localhost:8080/health
   - Should return: {"status":"healthy","qdrant":"connected","timestamp":"..."}
5. Stop Qdrant: docker-compose down
6. Test again: curl -s http://localhost:8080/health
   - Should return: {"status":"unhealthy","qdrant":"disconnected","timestamp":"..."} with 503
  </verify>
  <done>Health endpoint integrated into mcp-server, serving on configurable PORT</done>
</task>

</tasks>

<verification>
1. internal/mcp/health.go exists with NewHealthHandler
2. cmd/mcp-server/main.go starts HTTP server on PORT
3. curl http://localhost:8080/health returns valid JSON
4. Health check correctly reflects Qdrant connectivity status
</verification>

<success_criteria>
- Health handler created with proper JSON response structure
- HTTP server starts on configurable PORT (default 8080)
- Returns 200/healthy when Qdrant connected
- Returns 503/unhealthy when Qdrant disconnected
- Binds to 0.0.0.0 for Fly.io compatibility
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment/05-02-SUMMARY.md`
</output>
