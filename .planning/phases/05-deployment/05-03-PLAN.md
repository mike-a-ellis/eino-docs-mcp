---
phase: 05-deployment
plan: 03
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - fly.toml
autonomous: true

must_haves:
  truths:
    - "fly.toml configures MCP server and Qdrant as separate process groups"
    - "fly.toml defines volume mount point for Qdrant persistent storage"
    - "Health checks configured to verify /health endpoint"
    - "Deployment allocates sufficient resources for both processes"
  artifacts:
    - path: "fly.toml"
      provides: "Complete Fly.io deployment configuration"
      contains: "[processes]"
  key_links:
    - from: "fly.toml"
      to: "Dockerfile"
      via: "[build] dockerfile reference"
      pattern: 'dockerfile = "Dockerfile"'

# Note: Multi-image deployment
# - web process uses custom Dockerfile (built from golang:1.24 + distroless)
# - qdrant process uses official qdrant/qdrant Docker Hub image
# Fly.io supports multi-image process groups - each process can specify its own image source
# The qdrant process command (/usr/bin/qdrant) runs inside the qdrant/qdrant image, not our Dockerfile
---

<objective>
Create fly.toml configuration for Fly.io deployment with process groups.

Purpose: fly.toml defines how Fly.io runs the application - process groups for MCP server and Qdrant, volume mounts for persistence, health checks for reliability, and resource allocation.

Output: Complete fly.toml ready for `fly launch` deployment.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-deployment/05-RESEARCH.md
@.planning/phases/05-deployment/05-CONTEXT.md
@Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create fly.toml configuration</name>
  <files>fly.toml</files>
  <action>
Create fly.toml with complete Fly.io configuration:

```toml
# EINO Documentation MCP Server - Fly.io Configuration
app = "eino-docs-mcp"
primary_region = "iad"

# Graceful shutdown settings
kill_signal = "SIGINT"
kill_timeout = "20s"

[build]
  dockerfile = "Dockerfile"

# Process groups: MCP server (web) and Qdrant (sidecar)
[processes]
  web = "/app/mcp-server"
  qdrant = "/usr/bin/qdrant"

# Environment variables (non-sensitive only)
[env]
  PORT = "8080"
  QDRANT_HOST = "localhost"
  QDRANT_PORT = "6334"
  LOG_LEVEL = "info"

# HTTP service configuration for health checks and routing
[http_service]
  internal_port = 8080
  force_https = true
  auto_stop_machines = "off"
  auto_start_machines = true
  min_machines_running = 1
  processes = ["web"]

  [http_service.concurrency]
    type = "requests"
    soft_limit = 20
    hard_limit = 25

  # Health check configuration
  [[http_service.checks]]
    grace_period = "10s"
    interval = "15s"
    timeout = "5s"
    method = "GET"
    path = "/health"

# VM resources for MCP server (web process)
[[vm]]
  memory = "256mb"
  cpus = 1
  cpu_kind = "shared"
  processes = ["web"]

# VM resources for Qdrant (needs more RAM for vector operations)
[[vm]]
  memory = "512mb"
  cpus = 1
  cpu_kind = "shared"
  processes = ["qdrant"]

# Persistent volume for Qdrant data
[[mounts]]
  source = "qdrant_data"
  destination = "/qdrant/storage"
  processes = ["qdrant"]
  initial_size = "1gb"
```

Key decisions from CONTEXT.md:
- App name: eino-docs-mcp
- Region: iad (Virginia)
- MCP server: 256MB (smallest viable)
- Qdrant: 512MB (minimum for vector ops)
- Volume: 1GB (sufficient for EINO docs corpus)
- No snapshot retention (re-index from GitHub as recovery)
- QDRANT_HOST=localhost (same-host optimization per RESEARCH.md)
  </action>
  <verify>
1. Verify Qdrant binary path is correct (for fly.toml processes.qdrant value):
   ```bash
   docker run --rm qdrant/qdrant:latest which qdrant
   ```
   Expected: /usr/bin/qdrant

2. Validate fly.toml syntax (if flyctl installed):
   ```bash
   fly config validate
   ```

3. Manual requirement verification (check all are present):
   - [processes] section has both `web` and `qdrant` entries
   - [[mounts]] has `processes = ["qdrant"]` and `destination = "/qdrant/storage"`
   - [[http_service.checks]] has `path = "/health"`
   - [[vm]] sections allocate memory for web (256mb) and qdrant (512mb)
   - [build] references `dockerfile = "Dockerfile"`
  </verify>
  <done>fly.toml created with process groups, volumes, and health checks configured</done>
</task>

</tasks>

<verification>
1. fly.toml exists at project root
2. Contains [processes] with web and qdrant entries
3. Contains [[mounts]] with qdrant_data volume for qdrant process
4. Contains [[http_service.checks]] pointing to /health
5. VM memory: web=256mb, qdrant=512mb
6. If flyctl available: `fly config validate` passes
</verification>

<success_criteria>
- fly.toml exists with complete configuration
- Process groups define MCP server and Qdrant
- Persistent volume configured for Qdrant storage
- Health checks point to /health endpoint
- Resource limits match CONTEXT.md decisions
</success_criteria>

<output>
After completion, create `.planning/phases/05-deployment/05-03-SUMMARY.md`
</output>
