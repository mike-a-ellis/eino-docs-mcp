---
phase: 06-http-transport
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [internal/mcp/transport.go, internal/mcp/server.go]
autonomous: true

must_haves:
  truths:
    - "MCP server can create an HTTP handler via StreamableHTTPHandler"
    - "Underlying mcp.Server is accessible for HTTP transport wrapping"
    - "HTTP handler can be mounted on any http.ServeMux endpoint"
  artifacts:
    - path: "internal/mcp/transport.go"
      provides: "HTTP transport handler factory"
      exports: ["NewHTTPHandler"]
    - path: "internal/mcp/server.go"
      provides: "Accessor for underlying mcp.Server"
      exports: ["MCPServer"]
  key_links:
    - from: "internal/mcp/transport.go"
      to: "internal/mcp/server.go"
      via: "MCPServer() method returns *mcp.Server"
      pattern: "MCPServer\\(\\)"
---

<objective>
Add HTTP transport factory to the MCP server package using the SDK's StreamableHTTPHandler.

Purpose: Enable the MCP server to serve protocol over HTTP alongside existing stdio transport, which is required for remote client connections.

Output: New transport.go file with HTTP handler factory and updated server.go with accessor method.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-http-transport/06-RESEARCH.md

Reference code:
@internal/mcp/server.go
@internal/mcp/health.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add MCPServer accessor method</name>
  <files>internal/mcp/server.go</files>
  <action>
    Add a method to the Server struct that returns the underlying *mcp.Server:

    ```go
    // MCPServer returns the underlying MCP server instance.
    // Used by transport handlers that need to wrap the server.
    func (s *Server) MCPServer() *mcp.Server {
        return s.server
    }
    ```

    This accessor is needed because StreamableHTTPHandler requires the raw *mcp.Server,
    not the wrapper Server struct. Place this method after the Run method.
  </action>
  <verify>go build ./internal/mcp/... compiles without errors</verify>
  <done>MCPServer() method exists on Server struct and returns *mcp.Server</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP transport handler factory</name>
  <files>internal/mcp/transport.go</files>
  <action>
    Create a new file `internal/mcp/transport.go` with an HTTP handler factory function:

    ```go
    package mcp

    import (
        "net/http"

        "github.com/modelcontextprotocol/go-sdk/mcp"
    )

    // HTTPHandlerOptions configures the HTTP transport behavior.
    type HTTPHandlerOptions struct {
        // Stateless disables session management. Use for simple tool servers
        // that don't need server-to-client requests. Default: false (stateful).
        Stateless bool
    }

    // NewHTTPHandler creates an HTTP handler for the MCP server using Streamable HTTP transport.
    // The handler can be mounted on any http.ServeMux path (e.g., "/mcp").
    //
    // Example:
    //   mux := http.NewServeMux()
    //   mux.Handle("/mcp", mcpserver.NewHTTPHandler(server, nil))
    //   mux.HandleFunc("/health", healthHandler)
    //   http.ListenAndServe(":8080", mux)
    func NewHTTPHandler(server *Server, opts *HTTPHandlerOptions) http.Handler {
        if opts == nil {
            opts = &HTTPHandlerOptions{}
        }

        sdkOpts := &mcp.StreamableHTTPOptions{
            Stateless: opts.Stateless,
        }

        return mcp.NewStreamableHTTPHandler(func(r *http.Request) *mcp.Server {
            return server.MCPServer()
        }, sdkOpts)
    }
    ```

    Key design decisions (from research):
    - Use stateful mode by default (needed for future server-to-client requests)
    - Expose options struct for configurability
    - Return http.Handler interface for flexible mounting
    - Server factory function returns the same server instance (safe for concurrent requests since server doesn't modify internal state)
  </action>
  <verify>go build ./internal/mcp/... compiles without errors</verify>
  <done>NewHTTPHandler function exists, takes Server and options, returns http.Handler</done>
</task>

</tasks>

<verification>
1. Run `go build ./internal/mcp/...` - must compile without errors
2. Run `go test ./internal/mcp/...` - existing tests must pass
3. Verify transport.go exports NewHTTPHandler and HTTPHandlerOptions
4. Verify server.go now has MCPServer() method
</verification>

<success_criteria>
- internal/mcp/transport.go exists with NewHTTPHandler function
- internal/mcp/server.go has MCPServer() accessor method
- Package builds successfully
- All existing tests pass
</success_criteria>

<output>
After completion, create `.planning/phases/06-http-transport/06-01-SUMMARY.md`
</output>
