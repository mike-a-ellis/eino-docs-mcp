---
phase: 06-http-transport
plan: 02
type: execute
wave: 2
depends_on: [06-01]
files_modified: [cmd/mcp-server/main.go, fly.toml]
autonomous: false

must_haves:
  truths:
    - "MCP server serves protocol over HTTP at /mcp endpoint"
    - "Health endpoint continues working at /health"
    - "Stdio transport continues working when SERVER_MODE is not set"
    - "Remote MCP clients can connect to Fly.io deployment via HTTP"
  artifacts:
    - path: "cmd/mcp-server/main.go"
      provides: "Integrated HTTP server with both /mcp and /health endpoints"
      contains: ["NewHTTPHandler", "http.NewServeMux", "/mcp"]
    - path: "fly.toml"
      provides: "Production deployment configuration"
      contains: ["internal_port = 8080"]
  key_links:
    - from: "cmd/mcp-server/main.go"
      to: "internal/mcp/transport.go"
      via: "mcpserver.NewHTTPHandler call"
      pattern: "mcpserver\\.NewHTTPHandler"
    - from: "cmd/mcp-server/main.go"
      to: "internal/mcp/health.go"
      via: "mcpserver.NewHealthHandler call"
      pattern: "mcpserver\\.NewHealthHandler"
---

<objective>
Integrate HTTP transport into the main server binary and deploy to production.

Purpose: Enable remote MCP clients to connect to the Fly.io deployment via HTTP, completing the HTTP transport phase.

Output: Updated main.go with dual-mode operation and verified production deployment.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-http-transport/06-RESEARCH.md
@.planning/phases/06-http-transport/06-01-SUMMARY.md

Reference code:
@cmd/mcp-server/main.go
@fly.toml
@supervisor.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update main.go with HTTP mux and dual-mode operation</name>
  <files>cmd/mcp-server/main.go</files>
  <action>
    Refactor main.go to use http.ServeMux with both /health and /mcp endpoints.

    Key changes:
    1. Create http.ServeMux instead of using DefaultServeMux
    2. Mount health handler on /health (existing)
    3. Mount MCP HTTP handler on /mcp (new)
    4. In SERVER_MODE: start HTTP server and block
    5. Otherwise: run stdio transport for local development

    Replace the health server section and SERVER_MODE handling with:

    ```go
    // Create HTTP server with multiple endpoints
    mux := http.NewServeMux()

    // Health endpoint (for Fly.io health checks)
    healthHandler := mcpserver.NewHealthHandler(store)
    mux.HandleFunc("/health", healthHandler)

    // MCP HTTP endpoint (for remote client connections)
    mcpHTTPHandler := mcpserver.NewHTTPHandler(server, nil)
    mux.Handle("/mcp", mcpHTTPHandler)

    // Check if running in server mode (HTTP) or stdio mode (local development)
    serverMode := getEnv("SERVER_MODE", "false") == "true"

    if serverMode {
        // HTTP mode: serve MCP over HTTP for remote clients
        addr := "0.0.0.0:" + port
        log.Printf("Starting HTTP server on %s (MCP at /mcp, health at /health)", addr)
        if err := http.ListenAndServe(addr, mux); err != nil {
            log.Fatalf("HTTP server error: %v", err)
        }
    } else {
        // Stdio mode: run MCP server over stdin/stdout for local clients
        // Also start HTTP health endpoint in background for local testing
        go func() {
            addr := "0.0.0.0:" + port
            log.Printf("Starting health server on %s", addr)
            if err := http.ListenAndServe(addr, mux); err != nil {
                log.Printf("Health server error: %v", err)
            }
        }()

        log.Println("Starting EINO Documentation MCP Server (stdio mode)...")
        if err := server.Run(ctx); err != nil {
            log.Printf("server error: %v", err)
            os.Exit(1)
        }
    }
    ```

    Remove the old goroutine that started just the health server.
  </action>
  <verify>
    1. go build ./cmd/mcp-server - compiles without errors
    2. Local test: Run SERVER_MODE=true ./mcp-server and curl http://localhost:8080/health returns healthy
    3. Local test: curl http://localhost:8080/mcp returns MCP protocol response (or appropriate HTTP error)
  </verify>
  <done>
    - main.go uses http.ServeMux with /health and /mcp endpoints
    - SERVER_MODE=true starts HTTP server serving MCP
    - SERVER_MODE=false (or unset) runs stdio with health endpoint in background
  </done>
</task>

<task type="auto">
  <name>Task 2: Deploy to Fly.io and verify HTTP transport</name>
  <files>fly.toml</files>
  <action>
    Deploy the updated server to Fly.io:

    1. Verify fly.toml has correct configuration (no changes expected, but verify):
       - internal_port = 8080
       - SERVER_MODE = "true" in [env]
       - http_service configured correctly

    2. Deploy to Fly.io:
       ```bash
       fly deploy
       ```

    3. Verify deployment:
       - Check fly status shows machine running
       - Check health endpoint: curl https://eino-docs-mcp.fly.dev/health
       - Check MCP endpoint responds: curl -X POST https://eino-docs-mcp.fly.dev/mcp -H "Content-Type: application/json" -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
  </action>
  <verify>
    1. fly status shows 1 machine running
    2. Health endpoint returns 200 at https://eino-docs-mcp.fly.dev/health
    3. MCP endpoint responds to initialize request at https://eino-docs-mcp.fly.dev/mcp
  </verify>
  <done>
    - Server deployed to Fly.io
    - /health endpoint working
    - /mcp endpoint responding to MCP protocol requests
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>HTTP transport for MCP server deployed to production</what-built>
  <how-to-verify>
    1. Visit https://eino-docs-mcp.fly.dev/health - should return {"status":"healthy",...}
    2. Test MCP endpoint with curl:
       ```bash
       curl -X POST https://eino-docs-mcp.fly.dev/mcp \
         -H "Content-Type: application/json" \
         -d '{"jsonrpc":"2.0","id":1,"method":"initialize","params":{"protocolVersion":"2024-11-05","capabilities":{},"clientInfo":{"name":"test","version":"1.0"}}}'
       ```
       Should return MCP initialize response with server capabilities.
    3. (Optional) Configure Claude Desktop or another MCP client to connect via HTTP to verify full tool workflow.
  </how-to-verify>
  <resume-signal>Type "approved" if deployment works, or describe any issues</resume-signal>
</task>

</tasks>

<verification>
1. Health endpoint accessible at https://eino-docs-mcp.fly.dev/health
2. MCP endpoint accessible at https://eino-docs-mcp.fly.dev/mcp
3. MCP initialize request returns valid response with capabilities
4. Existing stdio mode still works locally (run without SERVER_MODE)
</verification>

<success_criteria>
- Server deployed and running on Fly.io
- /health returns healthy status (200 OK)
- /mcp accepts and responds to MCP protocol messages
- Remote MCP clients can connect via HTTP transport
</success_criteria>

<output>
After completion, create `.planning/phases/06-http-transport/06-02-SUMMARY.md`
</output>
