---
phase: 04-observability-manual-sync
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - internal/mcp/types.go
  - internal/mcp/handlers.go
  - internal/mcp/server.go
  - cmd/mcp-server/main.go
autonomous: true

must_haves:
  truths:
    - "User can call get_index_status MCP tool"
    - "Status returns total document count and chunk count"
    - "Status returns list of indexed document paths"
    - "Status returns last sync timestamp in ISO 8601 format"
    - "Status returns source commit SHA"
    - "Status includes commits_behind field showing staleness"
  artifacts:
    - path: "internal/mcp/types.go"
      provides: "StatusInput and StatusOutput type definitions"
      contains: "type StatusOutput struct"
    - path: "internal/mcp/handlers.go"
      provides: "makeStatusHandler factory function"
      contains: "func makeStatusHandler"
    - path: "internal/mcp/server.go"
      provides: "get_index_status tool registration"
      contains: "get_index_status"
  key_links:
    - from: "internal/mcp/handlers.go"
      to: "storage.ListDocumentPaths"
      via: "store.ListDocumentPaths call"
      pattern: "store\\.ListDocumentPaths"
    - from: "internal/mcp/handlers.go"
      to: "github.CompareCommits"
      via: "GitHub API call for staleness"
      pattern: "CompareCommits"
    - from: "internal/mcp/server.go"
      to: "makeStatusHandler"
      via: "tool registration"
      pattern: "makeStatusHandler"
---

<objective>
Implement the get_index_status MCP tool that reports index state, document counts, and data freshness.

Purpose: Users and AI agents can inspect what's indexed, when it was synced, and whether the index is stale compared to GitHub HEAD.
Output: New MCP tool `get_index_status` returning comprehensive index statistics with staleness indicator.
</objective>

<execution_context>
@/home/bull/.claude/get-shit-done/workflows/execute-plan.md
@/home/bull/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-observability-manual-sync/04-CONTEXT.md
@.planning/phases/04-observability-manual-sync/04-RESEARCH.md
@internal/mcp/types.go
@internal/mcp/handlers.go
@internal/mcp/server.go
@internal/storage/qdrant.go
@internal/github/client.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add status types and GitHub client dependency</name>
  <files>internal/mcp/types.go, internal/mcp/server.go</files>
  <action>
Add StatusInput and StatusOutput types to types.go following existing patterns:

```go
// StatusInput defines input for get_index_status tool (no parameters required)
type StatusInput struct{}

// StatusOutput contains index status information
type StatusOutput struct {
    // TotalDocs is the count of indexed documents
    TotalDocs int `json:"total_docs"`
    // TotalChunks is the count of document chunks
    TotalChunks int `json:"total_chunks"`
    // IndexedPaths lists all document paths in the index
    IndexedPaths []string `json:"indexed_paths"`
    // LastSyncTime is when the index was last updated (RFC3339)
    LastSyncTime string `json:"last_sync_time"`
    // SourceCommit is the GitHub commit SHA of indexed content
    SourceCommit string `json:"source_commit"`
    // CommitsBehind shows how many commits the index is behind GitHub HEAD (null if check failed)
    CommitsBehind *int `json:"commits_behind"`
    // StaleWarning is set when index is >20 commits behind
    StaleWarning string `json:"stale_warning,omitempty"`
}
```

Update Server struct in server.go to include GitHub client:
```go
type Server struct {
    server   *mcp.Server
    storage  *storage.QdrantStorage
    embedder *embedding.Embedder
    github   *github.Client  // NEW: for staleness check
}

type Config struct {
    Storage  *storage.QdrantStorage
    Embedder *embedding.Embedder
    GitHub   *github.Client  // NEW
}
```

Update NewServer to accept and store github client.
  </action>
  <verify>go build ./... succeeds with new types</verify>
  <done>StatusInput/Output types exist, Server has GitHub client field</done>
</task>

<task type="auto">
  <name>Task 2: Implement status handler with staleness check</name>
  <files>internal/mcp/handlers.go</files>
  <action>
Add makeStatusHandler factory function following existing handler patterns:

1. Get document paths using store.ListDocumentPaths(ctx, defaultRepository)
2. Get commit SHA using store.GetCommitSHA(ctx, defaultRepository)
3. Get last sync time by fetching one document's IndexedAt timestamp
4. Call GitHub CompareCommits to check staleness:
   - Compare indexed commit SHA (base) with "main" branch (head)
   - Extract AheadBy count for commits_behind field
   - Handle API errors gracefully (return nil for commits_behind, not error)
5. Set StaleWarning if commits_behind > 20

For chunk count: Use Qdrant's client.GetCollectionInfo() to get points_count, then subtract document count (points_count - len(paths) = chunks).

Error handling:
- Qdrant failures: Return error with "qdrant_error: " prefix
- GitHub failures: Return result with commits_behind = nil, don't fail the tool

GitHub compare call pattern (from research):
```go
comparison, _, err := ghClient.Repositories.CompareCommits(
    ctx,
    "cloudwego",
    "cloudwego.github.io",
    commitSHA,  // base (indexed)
    "main",     // head
    nil,
)
if err == nil && comparison != nil {
    commitsBehind = comparison.GetAheadBy()
}
```

Handler signature must match existing pattern:
```go
func makeStatusHandler(
    store *storage.QdrantStorage,
    ghClient *github.Client,
) func(context.Context, *mcp.CallToolRequest, StatusInput) (*mcp.CallToolResult, StatusOutput, error)
```
  </action>
  <verify>go build ./... succeeds, handler compiles without errors</verify>
  <done>makeStatusHandler exists with document counting, timestamp extraction, and GitHub staleness check</done>
</task>

<task type="auto">
  <name>Task 3: Register status tool and update main.go</name>
  <files>internal/mcp/server.go, cmd/mcp-server/main.go</files>
  <action>
In server.go NewServer function, add get_index_status tool registration after existing tools:

```go
mcp.AddTool(server, &mcp.Tool{
    Name:        "get_index_status",
    Description: "Get the current status of the EINO documentation index including document counts, last sync time, and staleness indicator.",
}, makeStatusHandler(cfg.Storage, cfg.GitHub))
```

Update main.go to initialize GitHub client and pass to server:

```go
import (
    // ... existing imports
    ghclient "github.com/bull/eino-mcp-server/internal/github"
)

// After embedder initialization:
ghClient, err := ghclient.NewClient(ctx)
if err != nil {
    log.Fatalf("failed to create GitHub client: %v", err)
}

server := mcpserver.NewServer(&mcpserver.Config{
    Storage:  store,
    Embedder: embedder,
    GitHub:   ghClient,  // NEW
})
```

Note: NewClient already handles GITHUB_TOKEN from environment for higher rate limits.
  </action>
  <verify>
1. go build ./cmd/mcp-server succeeds
2. go build ./... succeeds
  </verify>
  <done>get_index_status tool is registered and main.go initializes GitHub client</done>
</task>

</tasks>

<verification>
1. `go build ./...` compiles without errors
2. `go test ./internal/mcp/...` passes (if tests exist)
3. Manual verification (requires running Qdrant + indexed data):
   - Start MCP server
   - Call get_index_status tool
   - Verify response includes all fields
</verification>

<success_criteria>
- get_index_status MCP tool is registered and callable
- StatusOutput includes: total_docs, total_chunks, indexed_paths, last_sync_time, source_commit
- StatusOutput includes commits_behind field (nullable) for staleness
- StaleWarning is set when >20 commits behind
- Qdrant errors are prefixed with "qdrant_error:"
- GitHub API failures are handled gracefully (nil commits_behind, not error)
</success_criteria>

<output>
After completion, create `.planning/phases/04-observability-manual-sync/04-01-SUMMARY.md`
</output>
